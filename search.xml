<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>3月营地战棋项目总结</title>
    <url>/2020/04/27/3%E6%9C%88%E8%90%A5%E5%9C%B0%E6%88%98%E6%A3%8B%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这是关于我在3月份参与的一个单人卡牌roguelike游戏项目的初期开发相关总结。由于在项目开发流程中,动画,UI等部分主要由另一名合作者完成,所以在本文的内容中,我将主要总结在游戏逻辑相关开发中的一些收获。因为是杂谈性质的文章，应该不会有什么技术细节，仅将一些思路抛砖引玉。如果有时间的话也可以另开博文简单讲讲这次卡牌设计的相关思路或者游戏本身的介绍什么的。游戏的下载可以访问旅法师营地并搜索营地战棋专区。</p>
<span id="more"></span>

<h3 id="游戏流程概述"><a href="#游戏流程概述" class="headerlink" title="游戏流程概述"></a>游戏流程概述</h3><p>这次项目的玩法大致是炉石冒险+炉石酒馆战棋+炉石竞技场的神奇结合。开局选择英雄并进行若干次竞技场式选牌以确定牌池，之后依次与数个boss进行完整的1v1酒馆战棋战斗。每次战斗失败则游戏结束，胜利则获得一个宝藏并继续挑战。游戏的主体流程实现没有难点，主要难点集中在战棋模式战斗，操作的结算。</p>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p><em>以下名词解释基于读者对于炉石或类似卡牌游戏有充分了解，如读者对此类卡牌游戏毫无涉猎，接下来的内容可能难以阅读，请出门左转官网下载游戏一起成为无敌的恶魔猎手（此</em></p>
<p><strong>扳机</strong> : 一张卡牌触发效果的时机，例如:<br>        钴制卫士 3星6&#x2F;3 机械 每当你召唤一个机械，便获得圣盾<br>        此处 “每当你召唤一个机械”，便是一个召唤时扳机，表示每当玩家召唤一个机械，就会触发场上的钴制卫士的效果，使钴制卫士获得圣盾。游戏中存在大量的其他扳机机制，例如回收机器人的随从死亡时扳机，钢铁武道家的回合结束扳机等。扳机在此次项目中的实现<del>本应</del>是基于观察者模式。每当一个扳机入场便注册为游戏结算事件的观察者，离场时反之。当游戏发生事件时便通知所有的观察者，例如对于钴制卫士，召唤随从时便被通知，判断召唤的是机械后便执行之后的获得圣盾语句。</p>
<h3 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h3><p>接下来的内容是一些技术相关的收获和教训总结</p>
<h4 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h4><p>由于本次项目是和他人合作，我和合作者早期的交流也不很适应，所以框架的设计讨论并不充分，采取的方案可能不是最优解，仅供抛砖引玉。<br>因为在早期分工中制定了一人负责游戏逻辑，一人负责UI与动画的分工，也考虑到项目的实用性及可移植性，采用了模仿web开发的前后端信息交互模式。对于战棋模式中的一场战斗，在战斗开始时战斗过程与结果便由后端即游戏逻辑部分代码计算完毕并将战斗过程按照一定格式传递给前端。前端得到信息后，根据信息让随从互相撞击，播放对应动画等。另一方面，对于玩家的操作，例如选择了随从并购买，则由前端传递给后端进行处理。后端会在玩家手牌中添加该随从并减少对应铸币。当然，后端也会再次返回信息告知前端操作的后续影响，例如将酒馆中的该随从移动到手牌里，或者触发了购买时扳机等。这样的优点自然是降低耦合度，避免逻辑运算和动画处理混杂，同时因为后端代码是纯C#，也可以方便移植至服务器，甚至改造成多人游戏<del>做梦</del>。<br>当然这样也导致了一些问题，比如本次的合作者闲的没事手写UI写了7000行，我完全没能及时阻止。。<br>在后续的开发过程中，这几千行的UI代码大约要被简洁明了的UGUI替代吧。</p>
<h4 id="卡牌效果的定义"><a href="#卡牌效果的定义" class="headerlink" title="卡牌效果的定义"></a>卡牌效果的定义</h4><p>首先，我们进行一下简单的设想，如果游戏中存在一些有着复杂描述信息的卡牌，简单的实现思路是什么？<br>最容易想到的实现就是定义一个抽象卡牌基类，然后在其中为每个扳机定义抽象方法，在具体卡牌子类中实现。这样做的缺点简直数不胜数。例如如果有200张卡牌，便要写200个不同的卡牌类，简直离谱。作为一个懒惰的程序员，必然不能这样写。<br>稍显高级的思路是使用策略模式，不定义200个卡牌，而是对于每种行为定义策略，在卡牌中通过对策略的引用来实现不同的行为，当然也可以随时更换策略。在这个项目中，我便参考了此思路。使用了委托结合策略模式的思路实现卡牌的复杂效果。   </p>
<p>我们以上文中的钴制卫士为例，钴制卫士的效果是 召唤时扳机，如果召唤的是机械，就获得圣盾<br>事实上这段描述分为扳机和实际效果两部分，当扳机被通知时，扳机便将扳机得到的一些信息（例如此处的召唤的随从）传递给实际效果，实际效果部分判断这个随从是不是机械，如果是，则使钴制卫士获得圣盾。在理清了这个效果的本质后，一个 扳机-效果 的具体实现也就呼之欲出了。<br>显然，这里的效果事实上是一个委托，它的参数是扳机所要传递的信息（触发扳机的事件也即召唤的随从，扳机的所属者也即钴制卫士），内容则是使扳机的所属者钴制卫士获得圣盾。<br>结合上诉的策略模式思维，我们便可以将委托包装成卡牌的策略，使用枚举表示各种不同的扳机，得到包装后的扳机-委托对来实现复杂的卡牌描述<br>此处为委托对应的函数（已省略无关内容）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static bool GainDivineShieldWhenSummonMech(GameEvent gameEvent)</span><br><span class="line">&#123;</span><br><span class="line">    if (gameEvent.targetCard.IsMinionType(MinionType.Mechs))</span><br><span class="line">    &#123;</span><br><span class="line">        gameEvent.hostCard.effectsStay.Add(</span><br><span class="line">        new KeyWordEffect(Keyword.DivineShield));//获得圣盾</span><br><span class="line">        return true;            </span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处GameEvent为封装的游戏信息传递类，hostCard即钴制卫士，targetCard即召唤的随从<br>当游戏中发生了召唤随从事件时，钴制卫士就会被系统通知，调用上述函数并传入携带该事件具体信息的gameEvent参数，函数执行判断传入的随从是机械后即获得圣盾。<br>所以，只要将扳机与委托相互绑定并挂载在卡牌上，就能实现卡牌的复杂描述。  </p>
<h4 id="csv与反射机制的结合"><a href="#csv与反射机制的结合" class="headerlink" title="csv与反射机制的结合"></a>csv与反射机制的结合</h4><p>在框架设计中，采用了csv这一文件格式来存储卡牌并生成。在游戏的resource文件夹中的chess.csv存储了所有棋子的攻击力，生命值，描述，关键词等信息。当游戏初始化时，后端会读取csv中的所有棋子信息并生成一系列卡牌原型，之后战斗中生成的新卡牌实例生成均采用工厂模式在卡牌工厂中由卡牌原型生成，这样能够在不增加过多运行时开销的前提下将卡牌的数据与代码分离，方便策划的修改。策划只需要知道unity的界面使用而不需掌握代码知识，就能简单使用excel等工具修改csv并在unity中测试游戏。<br>当然，csv能读取的信息属实有限，我们显然无法将刚才提到的扳机-委托对直接存储在csv中。于是，便可以借助反射机制的帮助。我们可以使用特定的格式在csv中记录卡牌的扳机-委托对中的扳机信息与委托的函数名，同样在初始化时读取并绑定在对应的卡牌原型上。  </p>
<p><strong>例如</strong>：<br>钴制卫士在csv中的记录如下（已略去无关项）<br>钴制卫士,WhenMinionSummon:GainDivineShieldWhenSummonMech;,  </p>
<p>此处WhenMinionSummon即为扳机名，后续的即为刚才的委托的函数名。这里表示的效果即为上文所述钴制卫士的效果描述。读取的实现也较为简单，从csv中读到字符串后进行分割，使用反射机制分别以字符串的内容得到对应的信息，赋值给对应的卡牌原型即可。<br>当然在后续的开发过程中，为了支持mod，我们对csv的结构作出了重大调整。同时创造了一种脚本语言用于mod制作者的开发过程。所以这里的csv语法与格式已经是过去式了，新的格式可能会在下一阶段的总结博文（如果有的话）中介绍一下吧。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这次项目中自己的程序&#x2F;策划水平和社会经验都有了一定的提升，也算是获得了一小群玩家的认可，总体还算是收获颇丰。<br>当然，上线将近一个月后的现在来看，早期的设计也有许多不足之处，等以后有时间再重构吧。</p>
]]></content>
      <categories>
        <category>游戏开发</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>营地战棋</tag>
      </tags>
  </entry>
  <entry>
    <title>《Game AI Pro》2D潜行游戏中的AI</title>
    <url>/2021/02/20/%E3%80%8AGAP%E3%80%8B2D%E6%BD%9C%E8%A1%8C%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84AI/</url>
    <content><![CDATA[<p>关于《Game AI Pro》 How to Catch a Ninja: NPC Awareness in a 2D Stealth Platformer 的学习笔记。主要涉及以2D潜行游戏《忍者之印》为例的敌人AI设计<del>18年出了重置版还没有玩</del>。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《忍者之印（Mark of the Ninja）》是一款由Klei Entertainment发行的2D平台潜行游戏。玩家作为忍者，在阴影中潜行，并暗杀守卫与目标。为了解决AI角色对周围世界中的事件和物体有意识的需求，开发团队考虑的是数据驱动的兴趣系统，允许定义世界中的<strong>兴趣源</strong>（interest sources），并让智能体检测并对它们做出适当的反应。</p>
<h2 id="兴趣点"><a href="#兴趣点" class="headerlink" title="兴趣点"></a>兴趣点</h2><p>智能体们最初被设计为具有注意<strong>兴趣点</strong>（points of interest）的能力。兴趣点简单来说就是关卡中的一个2D点，一个可以接近但不一定要射击的东西。<br>这些兴趣点是在每个智能体的更新循环中从声音、尸体等来源创建的。更新循环将收集和迭代每一种类型的游戏对象。在收集了潜在的兴趣列表后，会根据距离的远近，或其他硬编码的标准，选择一个作为当前的兴趣，然后智能体将响应并作出行动。这种思路在某些情况下是可行的，但也有一些问题。<br>首先，如果策划想让智能体对任何新的、以前未定义的对象或事件感兴趣，他们就需要要求程序员在智能体的循环中添加一组新的检查，并可能添加新的数据结构来跟踪任何被感知的东西。游戏中最终设计了大约60种不同类型的兴趣源，这一问题严重阻碍了开发。<br>其次，没有考虑到多个智能体对同一兴趣点的反应。如果你发出了巨大的声响，附近的所有人都会跑来，这有一定的意义。但如果你打破了一盏灯呢？一群警卫都走过去，傻傻地盯着灯看，每个人都分别自言自语说，真该有人对那盏破灯做点什么，这有意义吗？<br>如果一群站在一起的智能体侦测到了一个兴趣点，理想的情况是，其中的一两个 “小组”会被解散去检查它，而其余的人只是处于警戒状态，等待搜索结果。这不仅让人感觉更自然，也为玩家提供了更多有趣的游戏思路。他们可以将紧密聚集的守卫分开并在黑暗的角落里单独对付他们，而不是跑到一个明亮的房间里被五个拿着自动武器的家伙射杀。    </p>
<h2 id="感知"><a href="#感知" class="headerlink" title="感知"></a>感知</h2><p>智能体需要在这个世界上检测两大类兴趣源，他们能看到的东西，和他们能听到的东西，这就有了两种感知：<strong>视觉</strong>和<strong>听觉</strong>。<br>视觉测试会检测以下问题：兴趣源是否在智能体的<strong>视锥</strong>范围内？与兴趣源相关联的游戏对象当前是否被光源照亮，或者智能体是否有夜视能力，从而取消了这一要求？智能体的眼睛位置和兴趣源的位置之间是否有任何物体阻挡视线？<br>视锥通常由一个偏移量和与智能体眼睛的方向、一个定义其视野宽度的角度和一个最大距离来定义，是一个三角形。其他的几何体也是可能的，例如根据需求，游戏中的视锥有的是一条射线，一个完整的圆，或者是一个正方形或梯形。<br>听觉检测是通过从兴趣源的位置到智能体的头部位置的路径查找来确定的。当策划从关卡编辑器中导出一个关卡时，其中一个步骤是从生成一个三角形网格（为了渲染地图也会生成关卡中所有实体碰撞的网格）。运行时便使用这个”声音网格”来执行A*路径查找。<br>与本作不同的另一种思路是采用兴趣源的位置到智能体的头部位置的欧几里得距离，这个方法的优点是直观且实现简单，声音的影响范围也能很好的以扩大的圆环（《这是我的战争》等作品）显示给玩家，但在真实感上略有欠缺。<br>出于性能和游戏性的原因，视觉和听觉的兴趣源定义了一个最大半径，只有在这个半径内的智能体才会被测试，以确定他们是否能检测到兴趣源。  </p>
<h2 id="兴趣源的定义"><a href="#兴趣源的定义" class="headerlink" title="兴趣源的定义"></a>兴趣源的定义</h2><p>现在可以允许策划创建一个兴趣源来代表任何他们想要的对象或事件，只要它能通过视觉或听觉检测被检测到。策划可以指定”枪声”、”脚步声”、”尸体”、或者”嫌疑人”。智能体的行为脚本可以使用指定的兴趣源类型来确定任何特殊的行为，但后台只需要知道如何确定智能体是否能看到或听到兴趣源。<br>你也可以将”视觉”和”听觉”的定义进行一定程度的改进。在《忍者之印》中，有一种特殊情况的智能体是警犬，它们能够在黑暗中”闻到”玩家的气味，但出于游戏性的考虑，它们只能在很短的距离内闻到。在这种情况下，我们并不需要创建一个全新的嗅觉检测，而是可以简单地定义一个附着在玩家游戏对象上的视觉兴趣源，并要求任何注意到它的智能体有”狗”标签，这就有了一个”气味”兴趣。<br>当然，这两种只是兴趣源的定义，智能体的大脑中并非只有这两种兴趣。例如当一个智能体被飞镖击中时，可以在他的大脑中添加一个”触觉”的兴趣，或者当智能体的伙伴去调查一个声音而没有回来时，可以添加一个”失踪伙伴”的兴趣。  </p>
<h2 id="智能体小队的处理"><a href="#智能体小队的处理" class="headerlink" title="智能体小队的处理"></a>智能体小队的处理</h2><p>另一个重要的问题是，当一群智能体同时检测到兴趣源时，他们应该如何反应。最开始的设计是每个人自己做自己的检测，当检测到一个兴趣源时就会做出反应，很可能是跑去调查它。这通常会导致整群智能体朝着最轻微的噪音跑去，或者集体向玩家汇聚。但优秀的潜行游戏中玩家能够操纵NPC，分散他们的注意力，并按照玩家自己的方式来戏弄他们。<br>于是我们需要寻找一种方法让智能体之间有某种程度的合作，但不至于明确地管理群体行为。发现状况后，一些人应该去调查，一个人可能会播放一行对话，告诉附近的另一个警卫去查看，其他人可能只是看了一眼，等待前面提到的警卫处理情况。<br>这里采取的方案是通过从兴趣源本身驱动来检测兴趣源，而不是从每个智能体单独驱动检测兴趣源，我们可以很容易地收集所有需要的信息，以确定谁应该做出反应，以及他们应该如何反应。<br>感官更新循环会根据所有可能的”检测候选者”来测试每个兴趣源。给定这个列表，它主要根据群体大小，但也可能根据位置或与兴趣源的距离做出一些决定。如果只有一个智能体能检测到兴趣，工作就完成了，智能体会得到通知，然后他去调查。如果有多个智能体可以检测到兴趣，我们可以给每个智能体分配角色，这些角色和兴趣记录一起存储在智能体的大脑中。角色只有在特定的兴趣范围内才有意义，当这个兴趣被遗忘或替换时，与之相关的角色也会消失。<br>如果有多个智能体能检测到兴趣，就会选择一个智能体作为”哨兵”或”组长”，他播放音频对话告诉附近的其他智能体去查看兴趣源，然后挂机在后面等待。一个或多个智能体会成为”调查者”，会去调查，似乎是听从”组长”的命令。其余的智能体会成为”旁观者”，可能会表示他们已经看到或听到了这个兴趣，但明智的做法是守住阵地，降低这个兴趣在他们心中的优先级，这样他们就更有可能注意到新的兴趣，也可能会被选为组长或调查员。<br>关键是，一旦角色分配完毕，感知更新完成，就没有”群体”需要管理了。每个智能体都是独立行动的，但由于被分配的角色不同，他们的行为方式也彼此不同，这使得群体显得协调一致。  </p>
<h2 id="兴趣的优先级"><a href="#兴趣的优先级" class="headerlink" title="兴趣的优先级"></a>兴趣的优先级</h2><p>如果你正在调查一盏破损的灯泡，突然遇到一具尸体，你应该停下来调查尸体，还是继续看灯？如果你听到你的伙伴被忍者刺伤，然后在去帮助他的路上发现了一盏破灯，你该怎么办？你应该停下来调查吗？显然，某些类型的兴趣必须优先于其他类型的兴趣。<br>在实际的实现中，兴趣源都包含一个简单的优先级整数值，高优先级的兴趣可以取代低优先级或同等优先级的兴趣，智能体会相应地改变自己的关注点。如果智能体当前持有高优先级的兴趣，低优先级的兴趣就会被舍弃。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INTEREST_PRIORITY_LOWEST = 0</span><br><span class="line">INTEREST_PRIORITY_BROKEN = 1</span><br><span class="line">INTEREST_PRIORITY_MISSING = 2</span><br><span class="line">INTEREST_PRIORITY_SUSPECT = 4</span><br><span class="line">INTEREST_PRIORITY_SMOKE = 4</span><br><span class="line">INTEREST_PRIORITY_CORPSE = 4</span><br><span class="line">INTEREST_PRIORITY_NOISE_QUIET = 4</span><br><span class="line">INTEREST_PRIORITY_NOISE_LOUD = 4</span><br><span class="line">INTEREST_PRIORITY_BOX = 5</span><br><span class="line">INTEREST_PRIORITY_SPIKEMINE = 5</span><br><span class="line">INTEREST_PRIORITY_DISTRACTIONFLARE = 10</span><br><span class="line">INTEREST_PRIORITY_TERROR = 20</span><br></pre></td></tr></table></figure>
<p>在整个开发过程中，平衡各种兴趣的优先级一直是一项具有挑战性的持续任务。上面的代码显示了在项目接近尾声时，各种类型的兴趣源的优先级是什么。<br>最初，开发团队假设寻找尸体将是游戏中最高优先级的兴趣之一，仅会被看到目标（玩家）所取代，但事实证明并不那么简单。如果你听到了一个声音，在调查声音的同时你发现了一具尸体，显然关注这个新发现是有意义的。但如果情况反过来呢？如果你正在调查一具尸体，而你又听到了声音，你应该忽略它吗？这有可能是非常不明智的，尤其是当声音是脚步声从后面迅速向你靠近的时候。<br>事实证明，尸体、噪音以及其他各种特定的兴趣类型都应该按照最新的优先原则来处理。你最后注意到的东西可能是最重要的东西。开发团队在这里的解决方案只是让这组兴趣都具有相同的优先级，且新的兴趣被视为更重要。<br>其他兴趣的优先级则和遇到的顺序无关。看到一个破损的罐子总是不如一个阴暗的人影或一声枪响来得有趣。看到你的伙伴被钉子陷阱刺穿，永远比远处的玻璃破碎声更重要。  </p>
<h2 id="智能体的侦查能力"><a href="#智能体的侦查能力" class="headerlink" title="智能体的侦查能力"></a>智能体的侦查能力</h2><p>一旦智能体注意到一个兴趣源，智能体就可以”调查”它，这可能仅仅意味着看着一盏坏掉的灯，并评论说它应该被修复。或者是看到一个倒下的战友，跑过去检查一下脉搏，然后打电话报告上级。<br>一旦智能体确定一个兴趣源已经被处理了，并不应该每个走过的警卫都停下来注意，这将是重复而无意义的。当一个智能体完成了调查及后续的任务后，与该智能体的兴趣记录相关联的兴趣源就会被标记为已调查，然后将该兴趣源（但不是与之相关联的游戏对象）从世界中移除，再也不会被看到或听到。<br>不过这仍然不能完全解决我们的问题，以尸体为例，如果你吸引了一个正在调查尸体的警卫的注意力，他还没来得及彻底调查并发出警报，会发生什么？失去目标后，他可能会转身再看到尸体。他看到倒下的战友显然并不会像刚才那样惊讶。他自然会回来完成最初的调查。我个人认为这是合理的行为，但是《忍者之印》的开发团队认为其过于复杂。开发团队决定，每个智能体一次只处理一个兴趣，不会有兴趣的堆叠或队列。一旦最高优先级的兴趣在任何时候被处理，情况能自然地重置到默认状态，而不是让警卫继续重温他们在遭遇中可能遇到的每一个过去的兴趣来源。在我看来可能维持一个容量不高的堆可能能在代价不大的情况使智能体的行为更真实。<br>那么默认情况下，每个智能体只检测或注意到每个兴趣源一次。当智能体注意到兴趣时，记录这次发现的发生，并且该智能体将被排除在再次注意到兴趣源的范围之外。由于我们从兴趣源的方向驱动更新并寻找智能体发现它们，因此兴趣源会保留一个发现者的列表，不会导致自己被同一个智能体注意两次。<br>在极少数情况下，一个兴趣源确实能被同一个智能体多次注意到，主要的例子是附加在玩家身上的”嫌疑犯”兴趣源。这个兴趣源在较远的地方就能被检测到，比智能体把玩家看成目标的能力还要强，从而吸引他们去调查，但并不需要看到就射击玩家。我们希望每次智能体侦测到玩家时都能更新这一兴趣源，所以这个特殊的兴趣源被标记为可被重新发现，它也不会费心去保留一份过去谁见过它的名单。<br>但是在这一套实现思路下，那些正在感知到快速重复或交替的兴趣的智能体很难实现合理的行为。为了解决这个问题，可以做一些特殊的处理。具体来说，当获取一个新的兴趣时，智能体会将新的兴趣与当前的兴趣（如果有）进行比较。如果它的来源、类型、优先级相同，并且与之前的兴趣的位置比较接近，那么就不会作为新的兴趣来处理，但当前兴趣的计时器和位置会更新以反映新的信息。一个主要的例子就是玩家在跑步时创建了一系列的脚步兴趣。把每一个脚步都当作一个新的兴趣是不可取的。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了《忍者之印》中基于兴趣的AI设计。虽然思路较为简单，但这个系统赋予了策划对游戏角色行为的更多控制权，同时减少了对特殊情况下硬编码脚本的需求。总的来说，在更新兴趣源时分配智能体行动的感知检测架构，加上数据驱动的带优先级兴趣源定义，形成了一个简单而灵活的系统，创造了可信的守卫意识，也以最小的额外复杂性提供了轻量级的群体行为。如果为了在自己的轻量潜行游戏中实现一套AI逻辑，不妨参考本文中的实现方案与细节。</p>
]]></content>
      <categories>
        <category>《Game AI Pro》</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac的终端美化</title>
    <url>/2020/05/10/Mac%E7%9A%84%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<p>这是关于使用 oh-my-zsh + iTerm2 + powerlevel10k 美化 Mac 平台 Terminal 的介绍</p>
<span id="more"></span>
<p>废话不多说先上成品  </p>
<p><img data-src="https://i.loli.net/2020/05/10/xjOBwPSLnZYDF58.png" alt="成品.png">  </p>
<p>虽然有点过于花里胡哨，不过把背景的二小姐去了改成单纯的高糊也不错，如下图所示</p>
<p><img data-src="https://i.loli.net/2020/05/10/EtJnk4YwjFz9dW3.png" alt="成品2.png"><br>图中随便敲的一些命令是用来展示oh-my-zsh中代码高亮和自动补全功能的。</p>
<p>接下来的内容就是打造这一花里胡哨终端的步骤。</p>
<ul>
<li>环境: MacOS 10.15.4  </li>
<li>工具: 自带Terminal oh-my-zsh iTerm2 powerlevel10k 主题<br>其中，oh-my-zsh为终端优化工具，iTerm2为终端替代品，而powerlevel10k为oh-my-zsh的一个优质第三方主题   </li>
<li>一些其他可能用到的工具&#x2F;环境: curl&#x2F;wget，git等</li>
</ul>
<h2 id="oh-my-zsh的安装与使用"><a href="#oh-my-zsh的安装与使用" class="headerlink" title="oh-my-zsh的安装与使用"></a>oh-my-zsh的安装与使用</h2><h3 id="oh-my-zsh的下载"><a href="#oh-my-zsh的下载" class="headerlink" title="oh-my-zsh的下载"></a>oh-my-zsh的下载</h3><p><a href="https://ohmyz.sh/">oh-my-zsh</a>是非常优秀的终端优化工具，它是基于zsh命令行的一个扩展工具集，提供了丰富的扩展功能。但它和Iterm2不同，并不提供命令行窗口，更不是一个独立的APP。<br>其在官网给出的下载方式有如下两个  </p>
<ul>
<li><p>使用 curl</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 wget</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure>
<p>我的电脑自带了curl，但是没有自带wget，你可以自行选择合适的方案安装<br>当然，很可能会出现类似连接失败之类的错误，而且尝试科学上网或终端科学上网可能均无效。这时我们可以注意到连接失败的是 <a href="https://raw.githubusercontent.com/">https://raw.githubusercontent.com</a> 这一网址，上网查询后可以得知这一网站常年被dns污染。于是可以按照如下步骤修改HOSTS文件解决。  </p>
</li>
<li><p>在终端中输入以下命令，使用vim修改hosts文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure></li>
<li><p>按 i 键(英文输入法)进入编辑模式</p>
</li>
<li><p>使用方向键将光标移到文本尾部，添加如下文本。其中151.101.72.133 可能会发生变化，如距文章发表日期较久，不保证有效，可以搜索引擎查询较新的解决方案</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">151.101.72.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure></li>
<li><p>按esc键退出编辑模式，然后输入 :wq! (需要输入冒号！),再按一下回车退出</p>
</li>
<li><p>重启终端重复下载步骤，dns污染的问题就解决了！</p>
</li>
</ul>
<p>下载成功界面大致如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ____  / /_     ____ ___  __  __   ____  _____/ /_  </span><br><span class="line"> / __ \/ __ \   / __ `__ \/ / / /  /_  / / ___/ __ \ </span><br><span class="line">/ /_/ / / / /  / / / / / / /_/ /    / /_(__  ) / / / </span><br><span class="line">\____/_/ /_/  /_/ /_/ /_/\__, /    /___/____/_/ /_/  </span><br><span class="line">                        /____/                       ....is now installed!</span><br><span class="line">Please look over the ~/.zshrc file to select plugins, themes, and options.</span><br><span class="line"></span><br><span class="line">p.s. Follow us at https://twitter.com/ohmyzsh.</span><br><span class="line"></span><br><span class="line">p.p.s. Get stickers and t-shirts at http://shop.planetargon.com.</span><br></pre></td></tr></table></figure>
<h3 id="oh-my-zsh的主题"><a href="#oh-my-zsh的主题" class="headerlink" title="oh-my-zsh的主题"></a>oh-my-zsh的主题</h3><p>oh-my-zsh 有许多<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/themes">官方主题</a>和<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/External-themes">第三方主题</a>，如果看中了某一款官方主题，就可以通过简单的设置切换成所需的主题，其中默认主题为robbyrussell。待会要提到的powerlevel10则是一款第三方主题。<br>例如，如果觉得下面这款agnoster主题不错,也是官方主题中和我的配置最相近的一款(虽然有字体相关的坑) ，便可以通过下列步骤设置为自己的主题。<br><img data-src="https://i.loli.net/2020/05/10/wvVj9NmXfcqPGyi.png" alt="agnoster.png"></p>
<ul>
<li>首先，vim打开配置文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure></li>
<li>接下来使用上面讲过的vim操作找到ZSH_THEME项并改成主题名字”agnoster”，保存退出<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZSH_THEME=&quot;agnoster&quot;</span><br></pre></td></tr></table></figure></li>
<li>再使用以下命令使刚才更改的配置生效<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ source ~/.zshrc   </span><br></pre></td></tr></table></figure>
重启终端后，如果你较为幸运，就能看到类似上面的效果了。<br>如果你和我一样悲惨地出现了乱码（例如箭头显示为问号），<br>也可以尝试下载安装powerline字体并尝试修改上述.zshrd设置文件将字体改为powerline字体。如果幸运的话，你同样能看到类似上面的效果。<br>但是，如果你和我一样仍然悲惨地出现了乱码并且不愿意更换其他风格主题，<br><em><strong>(注意：接下来介绍的powerlevel10k主题中如果选择使用复杂符号 (例如我的成品中的苹果符号) 或类似的彩色箭头 同样会出现这个问题)</strong></em><br>也可以采取我的邪道解决方案，也就是使用iterm2设置字体并将其作为新的终端，完全放弃自带的terminal。<br>具体的步骤稍后讲到iTerm2再说。<br>如果有人用其他方式解决了这一问题，也欢迎联系我。</li>
</ul>
<p>除此之外，也可以使用随机主题，只需如下设置，即可在每次开启命令行时随机挑选一个默认主题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZSH_THEME=&quot;random&quot;</span><br></pre></td></tr></table></figure>
<p>如果在使用随机主题的过程中发现了不错的主题，想要得知它的名字，也可以调用如下命令获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $ZSH_THEME</span><br></pre></td></tr></table></figure>
<h3 id="powerlevel10k主题的使用"><a href="#powerlevel10k主题的使用" class="headerlink" title="powerlevel10k主题的使用"></a>powerlevel10k主题的使用</h3><p>在成功尝试了agnoster或其他主题后，你可能觉得它们还算不错，但是自定义空间不够大&#x2F;不够花里胡哨什么的，这时，就需要<a href="https://github.com/romkatv/powerlevel10k">powerlevel10k</a>出场了。<br>powerlevel10k是一款优秀的第三方主题，也不仅仅是一款主题。事实上，它的个性化程度极高，仅需通过简单的配置即可达到其他主题的效果。安装了这一主题也就相当于安装了所有主题！<br><img data-src="https://i.loli.net/2020/05/10/aLBgSAGvD8MtKTC.png" alt="prompt-styles-high-contrast.png"><br>想要使用这一主题<br>只需从 github 下载该主题到 oh-my-zsh 目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/romkatv/powerlevel10k.git $ZSH_CUSTOM/themes/powerlevel10k</span><br></pre></td></tr></table></figure>
<p>再类似地修改 ZSH_THEME 为 powerlevel10k 并使配置生效即可。</p>
<p>重启终端之后，powerlevel10k的导航界面就会出现了。在这一阶段，powerlevel10k 先会询问一些问题以判断你的电脑是否安装了合适的字体。例如会展示一些符号，询问你是否出现乱码。再根据你的回答展示可用的个性化选项，只要简单的配置就能达成所需的个性主题。<br><img data-src="https://i.loli.net/2020/05/10/4rQYZpHnE1dL3zc.gif" alt="configuration-wizard.gif"><br>如果以后需要重新设置，也可以通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p10k configure</span><br></pre></td></tr></table></figure>
<p>命令再次进入这一导航。<br>当然，悲惨的我再次出现了大量乱码，使用了刚才介绍agnoster中提到的邪道方案才勉强能够使用。</p>
<h3 id="oh-my-zsh的插件"><a href="#oh-my-zsh的插件" class="headerlink" title="oh-my-zsh的插件"></a>oh-my-zsh的插件</h3><p>oh-my-zsh不仅能让你的终端更加花哨，也能让它更加高效。类似主题，oh-my-zsh有许多增强终端功能的<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins">官方插件</a>,也可以在<del>&#x2F;.oh-my-zsh&#x2F;plugins目录中查看插件列表。第三方插件由于我没有使用过，不加赘述。<br>插件的设置同样在</del>&#x2F;.zshrc 文件中，为plugins项。默认情况下仅启用了git插件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(git)</span><br></pre></td></tr></table></figure>
<p>如果想要使用更多插件可以在括号中添加，例如想要使用代码高亮插件zsh-syntax-highlighting和自动补全插件zsh-autosuggestions，就可以改成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(git zsh-autosuggestions zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure>
<p>其中自动补全插件可以在输入时使用tab查找可能的命令或是右方向键直接键入灰色的提示命令。</p>
<h2 id="iTerm2的安装与使用"><a href="#iTerm2的安装与使用" class="headerlink" title="iTerm2的安装与使用"></a>iTerm2的安装与使用</h2><p>虽然powerlevel10k的个性化程度很高，但是只是一个主题而已。如果想修改命令行的背景颜色&#x2F;字体颜色等属性，或是想要在背景中添加图片&#x2F;半透明&#x2F;高斯模糊，实现终端分屏，添加快捷键等效果，就需要iTerm2了。<br>iTerm2是一个独立的app，可以完全替代终端的使用，具有丰富的个性化选项。<br>iTerm2的安装较为友好，直接在<a href="https://www.iterm2.com/downloads.html">官网下载地址</a>下载安装包解压安装即可 .<br>也可以使用Homebrew安装  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew cask install iterm2</span><br></pre></td></tr></table></figure>
<p>安装iTerm2后你就可以放弃原本的Terminal了！<br>对于刚才的字体问题，邪道解决方案就是使用iTerm2方便的修改字体功能。</p>
<ul>
<li>下载合适的字体，这里可以选择<a href="https://www.nerdfonts.com/">Nerd-Fonts</a>,官网download界面中选择一款字体下载安装即可。这里我使用的是其中的Hack字体。  </li>
<li>使用command + ,键或上方菜单栏进入Preferences 配置界面</li>
<li>Profiles -&gt; Text -&gt; Font -&gt; Chanage Font，选择刚才安装的合适字体。</li>
</ul>
<p>另一个问题是IDE的终端并不能使用iTerm2，所以它会和自带终端一样出现乱码。当然这个问题也很好解决，搜索一下你的IDE的命令行修改字体方法，类似的改成合适字体即可。效果如下图所示。</p>
<p><img data-src="https://i.loli.net/2020/05/11/9EVr7KWnLSoR6FM.png" alt="截屏2020-05-11 上午2.18.06.png"><br>这样就能在iTerm2中使用花里胡哨的powerlevel10k了。虽然原本的终端里还是用不了，不过问题不大。<del>大不了不用了</del><br>iTerm2中还有许多其他的个性化选项。其中外观相关主要在 Profiles -&gt; Colors 和 Profiles -&gt; Window中。字体&#x2F;背景&#x2F;光标的颜色，窗口毛玻璃效果&#x2F;窗口背景图片等都在这两个选项卡中调整。其他的功能拓展就不赘述了。值得一提的是可以在Profiles -&gt; Keys -&gt; Hotkey左下角设置快速打开&#x2F;隐藏终端的快捷键。</p>
<h2 id="我的配置"><a href="#我的配置" class="headerlink" title="我的配置"></a>我的配置</h2><p>这是我本人目前使用的配置，有兴趣的可以参考一下。要提醒一下iTerm2背景图的缩放不算自由，寻找背景图时建议注意一下比例和背景颜色，必要时可以使用PS等工具进行处理。比如我这张就把白色部分更改成了灰色。</p>
<p><img data-src="https://i.loli.net/2020/05/11/zeGRviuO4QMCcrb.png" alt="截屏2020-05-11 上午2.06.36.png"></p>
<p><img data-src="https://i.loli.net/2020/05/11/kvUPmZqyiXjRJhr.png" alt="截屏2020-05-11 上午2.06.21.png"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>虽然是看起来简单的美化，不过也有一大堆乱七八糟的坑，一晚上才搞好。花里胡哨的代价还是挺大的。</p>
]]></content>
      <categories>
        <category>花里胡哨</category>
      </categories>
      <tags>
        <tag>zsh</tag>
        <tag>iTerm2</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>《Game AI Pro》使用转向圈的编队移动技术</title>
    <url>/2021/02/19/%E3%80%8AGAP%E3%80%8B%E4%BD%BF%E7%94%A8%E8%BD%AC%E5%90%91%E5%9C%88%E7%9A%84%E7%BC%96%E9%98%9F%E7%A7%BB%E5%8A%A8%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>关于《Game AI Pro》 Techniques for Formation Movement Using Steering Circles 的学习笔记。主要涉及使用转向圈规划编队的移动。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本章介绍了一个解决编队移动问题的方法，它是Chris Jurney在GDC演讲中提出的使用转向圈的想法的延伸。该解决方案可以分为两部分。</p>
<ol>
<li>生成要遵循的路径</li>
<li>沿着路径进行导航<br>这里值得注意的是，第一部分生成路径并不限于编队。它可以用于单个角色、车辆或任何其他可以定义转向圈的移动物体。第二部分是专门针对编队的，它描述了两种不同的沿路径移动编队的技术。</li>
</ol>
<h2 id="生成路径"><a href="#生成路径" class="headerlink" title="生成路径"></a>生成路径</h2><p><img data-src="https://i.loli.net/2021/02/19/H6ToSjQm2YnZv5V.png" alt="生成路径"><br>上图显示了所需的关键信息以及最终得到的路径。当开始生成路径时，从五个信息开始：编队的当前位置(formation.pos)、当前方向(formation.dir)、目标位置(target.pos)、目标方向(target.dir)和转向圈半径(或编队的转弯半径，r)。根据这些数据需要计算四个额外的值。</p>
<ul>
<li>c1，起始转向圈的中心点。</li>
<li>c1_exit，编队将脱离起始圆的点。</li>
<li>c2，结束转向圈的中心点。</li>
<li>c2_enter，编队与终点圆的连接点。</li>
</ul>
<h3 id="计算c1和c2"><a href="#计算c1和c2" class="headerlink" title="计算c1和c2"></a>计算c1和c2</h3><p>计算路径的第一步是生成将用于起点和终点的转向圈。为此需要圆心c1和c2。注意到dir实际上是转向圈的切线，且通常情况下转向圈在dir靠近目标点一侧生成，可以简单地通过几何计算得到圆心。只需注意当c1和c2之间的距离小于2r时，需要进行特殊考虑，分别在dir的相反方向生成圆。具体计算过程如下：  </p>
<ol>
<li>计算矢量target.pos-formation.pos，将其称为dirVec。  </li>
<li>计算起始圆的中心点c1。为此，需要与dirVec方向相同的formation.dir的法向量，将其标记为 formation.perp。将 formation.perp 的长度比例等于 r，然后将其加到 formation.pos 中，得到 c1。  </li>
<li>结尾圆的中心点 c2 用同样的方法计算，类似的半径向量将被称为target.perp。</li>
</ol>
<p>唯一的例外是当c1和c2之间的距离小于2r时(即，转向圈是重叠的)。这种情况下的解决方案是反转 formation.perp 和 target.perp。这将导致编队向相反的方向转向，从而有足够的空间。例如，如果最初使用 formation.dir 的右侧垂直线，将使用左侧垂直线，基本上是将转向圈翻转到 formation.dir 的另一侧。</p>
<h3 id="计算-c1-exit-和-c2-enter"><a href="#计算-c1-exit-和-c2-enter" class="headerlink" title="计算 c1_exit 和 c2_enter"></a>计算 c1_exit 和 c2_enter</h3><p><em>tldr：只需计算两个生成圆的公切线即可,此时这两点即为两个切点</em>    </p>
<p>接下来是计算c1_exit和c2_enter，有两种不同的情况需要考虑。为了确定是哪种情况，首先需要看position.perp和target.perp是position.dir和target.dir的左垂直还是右垂直。为了简洁起见，formation.perp如果是formation.dir的左手垂直线，则等于 “左”；否则就是 “右”。<br>第一种情况是针对formation.perp和target.perp相对的情况（例如，formation.perp等于右，target.perp等于左）。在这种情况下，我们的目标是计算c1_exit和c2_enter点在两个圆的圆周上相对于x轴的角度（也即下图中的a3和b3）。一旦有了这些角度，就可以计算出这两个点。<br>第二种情况是当formation.perp和target.perp在同一侧时。这种情况不需要计算任何角度，观察可知重要的角度都是90度。</p>
<h4 id="相对"><a href="#相对" class="headerlink" title="相对"></a>相对</h4><p><img data-src="https://i.loli.net/2021/02/19/3gn9jUfHKaisWLA.png" alt="情况1"><br>在 formation.perp 和 target.perp 不在同一侧的情况下，我们的目标是计算角度 a3 和 b3。需要注意的是，根据 formation.perp 和 target.perp 在哪条边上，a3 和 b3 的计算会略有变化，这就是为什么下图中有两部分。<br>在开始计算之前，有几个基本性质。首先，从c1到c1_exit的线和从c2到c2_enter的线都垂直于c1_exit和c2_enter之间的线。第二，c1到c2和c1_exit到c2_enter这两条线的中点相交。第三，知道转向圆的半径，r。第四，能够计算出c1和c2之间的距离，标为d。这意味着可以首先计算出角a1：$a1&#x3D;arccos(r&#x2F;(1&#x2F;2*d))$。还可以通过找出矢量c2-c1相对于x轴的角度来计算a2。<br>对于a3，需要使用的计算将取决于formation.perp和target.perp的值。如果 formation.perp 是 Right，那么可以参考图 A，a3 的计算是在 a2 上加上 a1。否则，如果 formation.perp 为左，参考图 B，a3 可以通过从 a2 中减去 a1 来计算。<br>c2_enter的计算与c1_exit的计算非常相似。角度b1的计算方法与用来计算a1的公式和数值完全相同。角度b2是矢量c1-c2相对于x轴的角度（不同于a2，它是c2-c1相对于x轴的角度）。b3的计算方法也和对a3的计算方法一样，只是b2-b1或b2+b1，这取决于formation.perp和target.perp的值。<br>最后，现在已经计算出了a3和b3，可以生成圆上的点，c1_exit和c2_enter。</p>
<h4 id="同侧"><a href="#同侧" class="headerlink" title="同侧"></a>同侧</h4><p><img data-src="https://i.loli.net/2021/02/19/JFxn1iKpwImWGEP.png" alt="情况2"><br>在formation.perp和target.perp都落在同一侧的情况下(意味着它们都是右或左)，计算就比较简单了，在这里，首先计算出向量c2-c1，称之为d。如图21.3所示，如果formation.perp等于右，那么将使用d的左手垂直线，标记为d.perp。同样，如果formation.perp等于Left，那么d.perp将是d的右手垂直线。无论哪种情况，一旦有了d.perp，将它加到c1和c2上，就会得到c1_exit和c2_enter。<br>最后，可以生成沿路径的点，让编队导航。这些点将从formation.pos开始，绕着圆圈c1移动到c1_exit，再移动到c2_enter，最后绕着圆圈c2移动，直到到达target.pos。<br>绕圈移动的方向由formation.perp和target.perp决定。当它们等于 “右 “时，在相应的圆上产生按顺时针方向绕行的点，当它们等于 “左 “时，产生按逆时针方向绕行的点。  </p>
<h3 id="生成沿路径的导航点"><a href="#生成沿路径的导航点" class="headerlink" title="生成沿路径的导航点"></a>生成沿路径的导航点</h3><p>最后，生成沿路径的点，让编队导航。这些点将从formation.pos开始，绕着圆圈c1移动到c1_exit，再移动到c2_enter，最后绕着圆圈c2移动，直到到达target.pos。<br>绕圈移动的方向由formation.perp和target.perp决定。当它们等于 “右 “时，在相应的圆上产生按顺时针方向绕行的点，当它们等于 “左 “时，产生按逆时针方向绕行的点。</p>
<h2 id="为编队导航"><a href="#为编队导航" class="headerlink" title="为编队导航"></a>为编队导航</h2><p>我们需要以一种看起来合理的方式移动编队。下面的例子将使编队的第一排保持静止，后面的几排将以几种不同的方式跟随。在这里介绍两种样式：第一种样式是将编队内的每个单位向它前面的单位移动，第二种样式则要求每个单位保持它的行，紧挨着它左右的单位。<br>请注意，这里描述的编队内的点是为了作为寻路目标，而不一定是编队内单位的实际位置。这种灵活性可以让单位离开去做其他事情，比如对付进攻的敌人，收集附近的资源，或者绕过较小的障碍物。一旦单位完成了它的任何一个子任务，它就可以继续寻路到它在阵中的目标位置。</p>
<h3 id="“列”式"><a href="#“列”式" class="headerlink" title="“列”式"></a>“列”式</h3><p>这种技术将编队中的每个单位向其前面的单位移动，同时保持一定的距离。虽然这将导致相当流畅的外观，并保持一列中每个单位之间的连接，但它不会保留行。<br>第一步是根据编队的速度和路径中的下一点，更新编队的位置和方向。为了使第一行的单位保持在一条直线上，需要计算它们的位置，使它们形成的直线与编队更新的方向垂直，并以编队的位置为中心。从第二行开始，计算每一个目标，和它前面同一列的目标之间的方向。然后，将目标向这个方向移动，直到它接触到前面的单位，对阵型中所有剩余行的单位重复这个过程。</p>
<h3 id="“行”式"><a href="#“行”式" class="headerlink" title="“行”式"></a>“行”式</h3><p>对于这种运动形式，编队在拐角处转向时保留了行。第一行的计算方式与“列”样式相同。<br>接下来需要根据第一行移动的方向，确定第二行是向左还是向右转。要做到这一点，首先计算从第二行的任何单位到第一行同列的单位的方向，然后取右侧的法向量，将其称为rPerpendicular。接下来，取第一行移动的方向与rPerpendicular的点积。如果该结果为正，则第二行将向右转，否则将向左转。<br>目前，假设第二行向左转。下一步将是把第二行中最左的单位向它前面同列的单位移动，直到它们相撞。接下来，从行中的第二个单元开始，将每个单元的位置设置为平齐它左边的单元，并向rPerpendicular的方向移动。<br>如果行是向右转，只有两个小的区别。最主要的是要先计算最右边的单元的位置，将它向它前面的单元移动，直到它们相碰。另一个区别是，你将从右边的第二个单元开始，并将每个单元的位置设置为触及它右边的单元，向-1*rPerpendicular的方向移动。<br>无论哪种情况，一旦有了第二行所有单元的位置，就可以对阵中的其余行重复这个过程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过根据编队的当前位置和目的地位置计算出两个转向圈，就可以为编队生成一条路径，以保证编队永远不需要进行超过其能力范围的急转弯。<br>这个概念的进一步发展可以包括让编队在大尺度和小尺度上考虑到障碍物的能力。对于较小的障碍物，意图是编队可以基本忽略它们。这是因为，编队内的寻路目标将负责寻找绕过任何小型障碍物的方法。大规模的障碍物需要单独处理，但可以通过考虑整个编队的大小，然后对整个编队进行寻路来处理。</p>
]]></content>
      <categories>
        <category>《Game AI Pro》</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>《Game AI Pro》使用迭代波前边扩展构建高层次导航网格</title>
    <url>/2021/02/17/%E3%80%8AGAP%E3%80%8B%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E6%B3%A2%E5%89%8D%E8%BE%B9%E6%89%A9%E5%B1%95%E6%9E%84%E5%BB%BA%E9%AB%98%E5%B1%82%E6%AC%A1%E5%AF%BC%E8%88%AA%E7%BD%91%E6%A0%BC/</url>
    <content><![CDATA[<p>关于《Game AI Pro》 Creating High-Order Navigation Meshes through Iterative Wavefront Edge Expansions 的学习笔记。主要涉及使用迭代波前边扩展<del>我也不知道怎么翻译</del>构建navmesh。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>传统上，导航网格是由人工创建的，或者使用某种形式的自动空间分解算法。这些算法检查环境中存在的障碍物，然后将它们之间的区域分解为尽可能少的区域。遗憾的是，为游戏环境创建一个具有最佳（绝对最小）区域数量的分解是NP的。这意味着并没有最好的技术。  </p>
<h3 id="三角分解方法"><a href="#三角分解方法" class="headerlink" title="三角分解方法"></a>三角分解方法</h3><p>当然，有许多种方法正在被尝试与改进。最经典的方法通常从某种形式的环境三角测量开始，然后试图通过组合这些三角形来最小化环境中存在的区域数量。<br>这种方法的问题在于，在导航网格中保留的三角形会给角色在许多三角形的公共顶点上的区域的导航带来问题。一个角色难以得知他们在汇合点上站在哪个区域。而这些汇合点在复杂的环境中经常出现，这就导致了各种各样的问题。  </p>
<h3 id="基于增长的方法"><a href="#基于增长的方法" class="headerlink" title="基于增长的方法"></a>基于增长的方法</h3><p>三角分解方法的替代方法是基于生长的方法，它将有助于最小化角色的localization问题。在作者之前的工作中，他们已经提出了基于生长的二维(PASFV)和三维(VASFV)空间分解定位算法，它的灵感来自于空间填充体积算法。虽然这些方法确实能生成高质量的导航网格，但在大型环境中执行时可能会很慢。这是因为这些算法要执行许多不必要的碰撞测试，因为它们必须验证每个生长区域在每个生长步骤中没有侵入另一个区域或障碍物。绝大多数时候，这种测试会返回一个否定的结果。这种不必要的测试是传统的基于生长的算法中顺序迭代扩展的结果。  </p>
<h3 id="波前算法"><a href="#波前算法" class="headerlink" title="波前算法"></a>波前算法</h3><p>于是作者开发了<strong>迭代波前边扩展单元分解</strong>（为简洁起见，简称<strong>波前</strong>）算法，通过减少碰撞测试和迭代增长来解决之前技术中的问题。该算法的工作原理是扫描放置在世界中的每个区域可见的世界几何体，并确定可能发生碰撞的地方。通过强制区域直接扩展到这些位置，消除了大量的碰撞测试。这改变了基于生长的算法的运行时间度量，使其随着世界的复杂性（障碍物的数量）而增加，而不是随着世界的面积而增加。这种技术不仅比现有的基于生长的技术快，而且产生的导航网格通过提供高阶多边形&#x2F;多面体几何区域，保留了PASFV和VASFV算法所表现出的高网格质量。接下来来看这一算法的具体实现思路。  </p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>大致步骤如下</p>
<ol>
<li>将单位大小的潜在区域（种子）放入世界中  </li>
<li>随机选择其中一个区域，从这个区域的角度分析世界中存在的障碍物  </li>
<li>所选区域进入加速扩张阶段。扩张的方向是算法第二步中分析发现的障碍物。对每个区域重复算法的第二步和第三步；这将使每个区域扩展到它们的最大可能尺寸。  </li>
<li>新的种子被放置到与刚刚创建的区域相邻的任何可遍历空间中，算法返回到第二步，让这些新的区域扩张。如果无法放置新的种子，算法就会终止。</li>
</ol>
<p>以下为步骤的详细介绍</p>
<h3 id="初始播种"><a href="#初始播种" class="headerlink" title="初始播种"></a>初始播种</h3><p>传统上，基于增长的算法首先使用基于网格的模式将初始单位大小的区域放入世界中。然后，这些方法迭代地给每个区域提供机会，使其沿着该区域的每个边的法线方向向外生长和扩展。<br>当在初始播种阶段使用波前算法时，我们会使用播种算法生成一个潜在的种子点列表，将潜在的种子放在每一个障碍物边旁边。与简单的网格播种相比，在放置更少的种子的同时有更好的整体覆盖率。然后，随机选择其中一个种子点作为初始区域。其他潜在的种子点将被保留在以后的播种队列中，但只有当它们仍然在未被某一区域占用的可达空间中时才会被使用。如果在以后的播种阶段，这个列表是空的，我们将尝试通过寻找与放置的区域相邻的无人认领的可达空间来重新填充它。如果在这之后这个列表仍然是空的，那么波前算法将终止。  </p>
<h3 id="边分类"><a href="#边分类" class="headerlink" title="边分类"></a>边分类</h3><p>在生成种子区域后，进入波前算法的边分类步骤。接下来的这两步是该算法中计算量最大的步骤，我们只希望在知道要扩展的有效区域上执行。因此每次只扩展一个区域，并舍弃被之前扩展所覆盖的空间中的种子。在这一步骤中，我们会遍历存在于世界中的障碍物的每一条边，以及存在于已经放置到环境中的区域中的所有边。然后，舍弃所有法向远离区域目标种子点的障碍物边，因为这些边是背向种子区域的，不能与种子区域交互。然后，根据这些边与目标区域位置相比的相对空间位置（+x、-x、+y、-y、+z、-z）将其分类。跨越多个类别的边被放置在第一个适用的类别中，这取决于算法实现中使用的评估顺序。作者的参考实现使用以下排序+y、-y、+x、-x、+z和-z。当然，任何排序都可以完成算法。<br>一旦这些障碍物边被排序，我们就会定位所有潜在的事件点。区域中法线与排序分类相匹配的边被称为<strong>分类边</strong>。通过比较每个障碍物边与适当的分类边的斜率，可以预先确定扩大的区域将如何与障碍物互动。这可以通过思考一个从初始种子点绘制的径向半平面扫描来可视化。这条扫描线将报告它发现的边的方向以及边上最接近初始种子点的点。这些被占用空间的边和刚刚放置的区域边之间的相互作用可以简化为一系列的情况。<br><img data-src="https://i.loli.net/2021/02/19/a8FzHqyimr2SV76.png" alt="情况1"><br>其中第一种情况是，障碍物边与分类边平行，如上图所示。在这种情况下，我们希望扩张分类边，使其与目标边平齐。通过考察边上离正在评估的区域的初始种子点最近的点来实现这一操作。我们会将这个点以及从它到区域初始种子点的距离作为一个<strong>事件</strong>记录下来。同时，由于所有已完成扩张的种子区域和正在扩展的区域都只暴露出轴对齐的边，因此任何涉及已被占用的可达空间的情况都属于这一类。<br><img data-src="https://i.loli.net/2021/02/19/3AqpLCGJeXZiYfu.png" alt="情况2"><br>如上图所示，当分类边将与障碍物的一个角相遇时，就会出现一种稍微复杂的情况。在这种情况下只能平行地扩展区域使这个角的顶点位于分类边上。不能改变分类边的斜率，因为这将可能覆盖到之前已完成的种子区域扩张占用的可达空间，这将违反被某一区域占用的空间必须始终保持被该区域占用这一原则。这种情况同样会存储被评估边上最近的顶点的位置以及该顶点到区域初始种子点的距离。<br><img data-src="https://i.loli.net/2021/02/19/iUxqoMIrWLyNPfc.png" alt="情况3"><br>接下来这种情况更为复杂，它可能会导致在扩大的区域中增加新的边。如上图所示，最近的障碍边中间的某点与扫描线相交。这是一种<strong>边分割</strong>的情况，为了计算这种分割应该发生在哪里，我们要找到正在被考虑的障碍物边上最接近区域初始种子点的点。然后，这个点和这个点与区域的初始种子点之间的距离一起被存储为事件点。此外，存储被考虑的边的两个端点（假设最近的点不是端点），这样将能为这个区域增加一条与交点到某一端点长度相同的新边。然而，我们将不计算这些端点与初始种子点之间的距离，而是将它们视为一种只比事件点离初始种子点稍远一些的特殊情况。这将防止这些点在过程中干扰其他计算。<br><img data-src="https://i.loli.net/2021/02/19/3pdqu8k5xTbtBgn.png" alt="情况4"><br>上图中可以看到一个更复杂的情况，有多个边分割事件。这样的事件应该根据扩张区域的初始种子点的距离来依次处理，通过考虑这些端点的距离确保区域在处理该点时，尽量将其中间的所有空间完全包含在内。<br>此时，已经有了一个潜在事件的集合，从而让新区域向着这个空间扩展。但是，在开始扩展之前，需要做两件事。首先，如果世界的边界被定义为一些边界条件，而非不可达的空间，则需要插入事件以允许每个区域向外扩展到世界的边界。同时这个列表需要根据每个事件与区域的初始种子点之间的距离进行排序。从而先处理距离较近、更有可能到达的事件，因为更远的事件往往因为存在更直接的障碍物而无法到达。</p>
<h3 id="边扩展"><a href="#边扩展" class="headerlink" title="边扩展"></a>边扩展</h3><p>有了某个区域的完整潜在事件列表，就可以进入波前算法的扩展阶段。首先，选择第一个（最接近的）未处理的扩展事件，并从潜在事件列表中删除。然后计算区域边必须移动的距离，以便它们到达这个扩展事件点。这是通过计算两个（三维中的三个）最接近的边的当前位置和目标扩展位置之间的距离来完成的。这个结果会被分解成几个分量（x, y, z），如果这些值是正数，边将直接扩张到事件点。扩张应该随着每个边迭代地向外移动而发生。所有的边都移动了之后，就可以执行碰撞和无效扩展的检查。之所以会发生这种情况，是因为有一些分割事件，如果只执行一半的事件（即允许一条边而不是两条边扩展），可能会出现各种问题。<br>区域完成扩展时，必须处理任何与其他区域或障碍物的碰撞。任何与障碍物碰撞的扩展区域的顶点处需要插入一条新的边来将该区域转换为一个高阶多边形&#x2F;多面体。为了构造这个新边，可以取障碍边的相反法线，并将这个新边约束在障碍边的外延上。由于扩展事件是孤立计算的，并没有考虑其他区域，因此有可能发生碰撞，此时区域将不得不从潜在的膨胀事件中收缩。如果发生这种情况，发生碰撞的边应该停止进一步的扩张尝试；然后，算法将选择另一个扩张事件继续处理。重复这一过程，直到没有更多的事件或其所有边因碰撞而停止尝试扩张。</p>
<h3 id="重新播种"><a href="#重新播种" class="headerlink" title="重新播种"></a>重新播种</h3><p>在所有种子完成扩展后，将按照前面的播种过程放置更多的种子。如果算法进入播种阶段，但无法放置任何新的区域，它就会终止。这样就会产生一个区域集合，即为所需的navimesh。</p>
<h2 id="后处理步骤"><a href="#后处理步骤" class="headerlink" title="后处理步骤"></a>后处理步骤</h2><p>现有的基于增长的空间分解算法(如PASFV、VASFV和SFV)利用了一个后处理步骤来提高所得导航网格的质量。有时其中两个或更多的区域会成长为一个可以由单个凸区域填充的环境区域。这是同时放置和生长多个种子的自然结果，通常会通过合并区域来纠正。然而，这种组合需要花费时间和精力。波前算法的一个优点是它避免了大部分这种形式的后处理。由于两个区域永远不会同时生长，它们不能同时试图细分同一可达空间的凸形区域，从而产生更好的分解。</p>
<h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p>波前算法最坏情况下的运行时间受其执行的环境复杂度的限制，为O(n*m)。其中，n是世界中预设的障碍物的数量，每个障碍物都必须由算法播种的m个区域来评估。这个运行时间可能看起来比现有的基于生长的空间分解算法更差，但这些算法的运行时间会根据世界的大小而增加（由于必须执行额外的生长步骤以填充世界），而波前算法的运行时间只会随着环境的实际复杂程度而增加。一般来说，波前算法的平均运行时间在毫秒到秒的范围内，而相比之下，基于增长的实现的运行时间在几秒到几分钟的范围内。同时，波前算法的内存占用是线性增长的，因为每个新生成的区域只需要在任何给定的时间点上与现有的区域和障碍物进行交互和了解。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img data-src="https://i.loli.net/2021/02/19/WQTL3A6wHXuFsPS.png" alt="截屏2021-02-19 上午2.52.29.png"></p>
<p>以上即为一个波前算法的运行结果。<br>总的来说，波前算法通过基于四边形的扩展算法生成快速、高质量的分解。这种分解有较少的小区域和退化区域（一般是三角形），而这些区域会干扰角色的导航。这种算法通过执行较少的扩展步骤改进了以前基于生长的方法，从而减少了必须执行的碰撞测试的数量。它的运行时间随世界的复杂性而扩展，而不是像现有的基于生长的方法那样随世界的大小而扩展。此外，由于该算法每次只生长一个区域，减少了通常由多个区域竞争填充同一凸区域而引起的后处理。本算法产生的分解与现有流行算法（如Hertel-Melhlorn或梯形单元分解<del>两个奇怪的我没听说也搜不到的算法</del>）产生的分解相比，效果较好。</p>
]]></content>
      <categories>
        <category>《Game AI Pro》</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>《Game AI Pro》寻路算法的优化</title>
    <url>/2021/02/10/%E3%80%8AGAP%E3%80%8B%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>关于《Game AI Pro》 Pathfinding Architecture Optimizations和 Choosing a Search Space Representation的学习笔记，主要涉及$\mathrm{A*}$算法的一些优化以及搜索空间表示的选择，需要读者对$\mathrm{A*}$算法有基本的了解。（之前的章节懒得补博客了</p>
<span id="more"></span>

<h3 id="使用查找表构造高质量的启发因子"><a href="#使用查找表构造高质量的启发因子" class="headerlink" title="使用查找表构造高质量的启发因子"></a>使用查找表构造高质量的启发因子</h3><p>我们可以使用$Floyd$算法预先得到一个查找表，将它压缩后在实时运算中作为 $\mathrm{A*}$ 算法的启发因子。<del>毕竟不压缩就不需要 $\mathrm{A*}$ 了</del><br>这里压缩的方法在2012年的GPPC（Grid-Based Path Planning competition，基于网格地图寻路的比赛，JPS跳点算法也在其中被提出）中被提出。当然这一压缩方法也不仅适用于网格地图。<br>在一个地图中，会有许多关键的节点，在FLoyd算法的查找表中，到这些节点的路径会被反复计算，这些点被称为<strong>枢纽</strong>，对于每个点z，在查找表中只记录到枢纽的距离d（p，z），当我们需要两个点间的估计距离作为启发因子时，令 $h(x, y) &#x3D; |d(p, x) – d(p, y)|$即可。如果我们选择了多个枢纽，就选取以每个枢纽计算得到的估计距离中的最大值。这一方法被称为<strong>欧氏嵌入</strong> (Euclidean embedding)，兼顾了空间与时间。<br>接下来的问题则是枢纽的选择，这因游戏类型而异。例如，在一个RTS游戏中，可以选取双方的基地为枢纽；在一个RPG游戏中，则可以选择地图的出入口和主城为枢纽。</p>
<h3 id="更好的搜索空间表示"><a href="#更好的搜索空间表示" class="headerlink" title="更好的搜索空间表示"></a>更好的搜索空间表示</h3><p>常见的三种表示是基于<strong>方格</strong>(grid)、<strong>路点</strong>(waypoint)、<strong>导航网格</strong>(navmesh)<br><img data-src="https://i.loli.net/2021/02/12/jM2XtqRxy6LriUk.png" alt="搜索空间描述">  </p>
<p>其思路不再赘述，以下为几种搜索空间表示的优劣对比。</p>
<h4 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h4><ul>
<li>优点  <ul>
<li>简单，易于实现</li>
<li>对地图编辑器友好</li>
<li>特定方格的消耗&#x2F;可通行性易于修改，当然重新加权的方格太多也会影响速度</li>
<li>从游戏地图位置容易映射到方格位置，坐标除以每个网格的边长即可</li>
</ul>
</li>
<li>缺点<ul>
<li>对于大型地图，方格属于内存密集型</li>
<li>通常需要对所得的路径进行路径平滑</li>
<li>由于粒度过细，路径规划的消耗可能较大</li>
<li>通常含有许多对称路径，增加了路径规划的成本。这一问题可以通过一些技术缓解</li>
</ul>
</li>
</ul>
<h4 id="Waypoint"><a href="#Waypoint" class="headerlink" title="Waypoint"></a>Waypoint</h4><ul>
<li>优点  <ul>
<li>同样易于实现</li>
<li>如果能够提前预知改动（例如一扇门的开关），则同样易于修改</li>
<li>稀疏的表示使得存储和路径规划的消耗都较低</li>
</ul>
</li>
<li>缺点<ul>
<li>如果边过少，路径质量会受到影响；过多则会影响存储与路径规划的复杂度</li>
<li>需要手动放置节点才能得到较好的路径质量</li>
<li>玩家的位置映射到路点图的数据结构（localization）较为困难，玩家被碰撞出边时可能难以定位</li>
<li>未储存明确的物理等底层状态空间表示信息，平滑路径时可能会导致角色卡在物理对象上</li>
<li>如果改动无法被预知，修改的过程较为复杂，需要验证附近的所有路点是否因为地形修改导致可被连接。（例如角色可以任意地进行墙体破坏）</li>
</ul>
</li>
</ul>
<h4 id="Navmesh"><a href="#Navmesh" class="headerlink" title="Navmesh"></a>Navmesh</h4><ul>
<li>优点  <ul>
<li>多边形可以比网格更精确地表示游戏世界，因为它可以处理非网格对齐的地图</li>
<li>多边形精确表示有利于路径的平滑</li>
<li>路径规划非常快且不影响质量</li>
<li>不像网格一样消耗内存</li>
</ul>
</li>
<li>缺点<ul>
<li>实现过于复杂，不过有非常不错的开源实现</li>
<li>需要使用特殊的几何算法，在某些特殊情况（如平行线）可能导致失败。这更增加了实现的难度</li>
<li>对导航网格的改动可能难以实现且消耗较大</li>
<li>如果实现不好，localization可能比较复杂。优秀的实现可能会借助额外的数据结构，如gird进行映射</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>每种路径规划架构都有自己的优点和缺点。架构的选择应该取决于正在开发的游戏类型、已有的工具以及可用于实现和调试的时间。许多游戏引擎都自带路径规划表示，但对于必须进行新的实现的情况，其优缺点总结如下。<br>当地形是2D时，当实现时间有限，当世界是动态时，当内存充足时，网格是最有用的。它们并不适合大型的开放世界游戏，或者需要高质量动画的可行走空间的精确边界的游戏。<br>当实现时间有限，需要快速路径规划，以及不需要世界的精确表示时，路点图是最有用的。当有足够的时间进行测试和实现时，导航网格是最好的。如果实现得好，导航网格是最灵活的实现方式，但对于小项目来说，导航网格可能是矫枉过正。<br>但是在大型游戏中，简单地使用这些表示方式可能并不能解决问题。常用的方法是分层寻路，例如在不需要精细寻路的高层次中采用路点或导航网格描述，低层次中使用方格。当存储空间不足以使用上述的$Floyd$查找表时便可以采取这一思路。其在英雄连、龙腾世纪：起源等游戏中被采用。</p>
<h3 id="预分配所有重要的存储空间"><a href="#预分配所有重要的存储空间" class="headerlink" title="预分配所有重要的存储空间"></a>预分配所有重要的存储空间</h3><p>在搜索过程中分配存储空间会导致效率数量级级别的下降。所以应当使用内存池预分配搜索所需的空间。</p>
<h3 id="高估启发因子"><a href="#高估启发因子" class="headerlink" title="高估启发因子"></a>高估启发因子</h3><p>$\mathrm{A*}$作为具有<strong>可采纳性</strong>(admissible) 的寻路算法，其对于当前节点到目标的距离估算需不高于实际的距离。不过在实际项目中，你可以通过适当地高估启发因子舍弃部分可采纳性以换取巨大的速度提升。在传统寻路领域中，这听起来简直离经叛道，但在电子游戏领域，这是一种可行的权衡。<br>为了理解具体的高估方式，我们来看传统的$\mathrm{A*}$开销计算函数<br>\begin{equation}<br>f(x)&#x3D;g(x)+h(x)<br>\end{equation}<br>对启发因子进行加权后形式如下<br>\begin{equation}<br>f(x)&#x3D;g(x)+h(x)\times weight<br>\end{equation}<br>通过调整权重$weight$，即可得到不同的$\mathrm{A*}$形式。如果权重为0，退化为$Dijkstra$算法，开销估计仅由之前的累计消耗决定。如果权重为1，即为经典的$\mathrm{A*}$算法。如果权重大于1，则算法向贪婪最佳优先算法(Greedy  Best-First search)靠近。<br>在实际操作中，我们可以将权重在1.1到1.5之间调整，这取决于你的地图形式。如果你的地图较为复杂，充斥着随机障碍与回溯，这种方法对可采纳性的破坏则较为严重；如果你的地图较为简单，增大权重将极大地增加寻路算法靠近终点的速度。虽然这一方法有一定风险，也不失为值得探索的思路。</p>
<h3 id="更好的启发因子"><a href="#更好的启发因子" class="headerlink" title="更好的启发因子"></a>更好的启发因子</h3><p>对于一个能8方向移动的方格地图而言，常见的启发因子有以下三种</p>
<ul>
<li>欧氏距离 Euclidean distance 通常会低估实际消耗</li>
<li>曼哈顿距离 Manhattan distance 通常会高估实际消耗</li>
<li>八分距离 octile distance 对于此类地图是较优的启发因子，允许45度和90度的转弯，计算方式为$max(Δx, Δy) + 0.41 · min(Δx, Δy)$</li>
</ul>
<h3 id="开放队列排序"><a href="#开放队列排序" class="headerlink" title="开放队列排序"></a>开放队列排序</h3><ul>
<li>常见的存储开放队列的方式是堆，但是由于新加入的节点经常被立刻删除，可以在删除前先缓存新节点。</li>
<li>还可以避免显式排序。在某些地图中，独一无二的f会比较少，这种情况可以改为维护f的列表而非节点的列表</li>
<li>在一些搜索中，开放列表中只有10到30个节点，这时直接使用数组存储开放列表可能较为简单</li>
</ul>
<h3 id="避免寻路中的回溯"><a href="#避免寻路中的回溯" class="headerlink" title="避免寻路中的回溯"></a>避免寻路中的回溯</h3><p>即使是最简单的剔除（例如剔除已经经过的节点）也能极大地加快寻路的速度。更为高级的剔除则衍生出了$\mathrm{A*}$的许多变种，例如前文提到的JPS跳点算法</p>
<h3 id="缓存后继任务"><a href="#缓存后继任务" class="headerlink" title="缓存后继任务"></a>缓存后继任务</h3><p>$\mathrm{A*}$算法需要频繁地考察相邻的节点，故直接将相邻节点存储起来而非在复杂的数据结构中遍历也能提高速度，当然这会导致更大的空间消耗。</p>
<h3 id="寻路中的坏主意"><a href="#寻路中的坏主意" class="headerlink" title="寻路中的坏主意"></a>寻路中的坏主意</h3><h4 id="同时搜索"><a href="#同时搜索" class="headerlink" title="同时搜索"></a>同时搜索</h4><p>尽量避免同时开始多次搜索。因为$\mathrm{A*}$算法需要开辟较大的空间，同时进行多个搜索会导致极大的空间消耗。如果我们发现搜索的速度确实差距较大，可以分两个通道分别处理一般的寻路和较慢的寻路。</p>
<h4 id="双向寻路"><a href="#双向寻路" class="headerlink" title="双向寻路"></a>双向寻路</h4><p>一般而言，当有大陆-岛屿存在时，双向寻路可以通过快速遍历岛屿上的节点迅速判断出发点和目标之间的不可达关系，而$\mathrm{A*}$需要遍历大陆中的节点得出同样的结论。但这并非使用双向寻路的理由，解决这个问题可以通过分层寻路，在宏观上先判断可达性，再使用$\mathrm{A*}$得到具体路径。<br>当然，抛开岛屿问题，双向寻路对于$\mathrm{A*}$也徒劳无功。所以，不要在$\mathrm{A*}$中使用双向寻路。</p>
<h4 id="缓存失败的寻路结果"><a href="#缓存失败的寻路结果" class="headerlink" title="缓存失败的寻路结果"></a>缓存失败的寻路结果</h4><p>在某些算法中，缓存中间结果可以减少重复计算，但在$\mathrm{A*}$中并不适用，因为有太多不同的路径，存储中间结果对于空间的消耗过大。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上即为一些常用的$\mathrm{A*}$算法优化方式，希望能给读者一些启发。</p>
]]></content>
      <categories>
        <category>《Game AI Pro》</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>《Game AI Pro》高效的人群模拟</title>
    <url>/2021/02/19/%E3%80%8AGAP%E3%80%8B%E9%AB%98%E6%95%88%E7%9A%84%E4%BA%BA%E7%BE%A4%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<p>关于《Game AI Pro》 Efficient Crowd Simulation for Mobile Games 的学习笔记。主要涉及构建高效的人群模拟。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>人群模拟是游戏人工智能行业不断探索和尝试的课题。现代游戏中充斥着越来越多的AI控制的智能体。因此，创建一个真实、稳健、对设计者友好的运动系统势在必行。<br>虽然许多路径可能有相似的部分，传统的寻路方法为各个智能体计算单独的路径。这些冗余的路径计算限制了在移动设备上对大量单位的模拟。<br>移动塔防游戏《Fieldrunners 2》使用矢量流场和操纵行为的组合来有效地模拟成千上万的智能体，即所谓的单位。本文将介绍Fieldrunners 2所采用的流场生成、流采样和单位移动的系统以及动态人群模拟系统的构建和平衡过程。</p>
<h2 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h2><p>网格提供了游戏世界的差异化，并定义了单位可以在其中移动的区域。对于《Fieldrunners 2》，网格单元的大小比最宽的单位略宽，因此每个计算出的路径都可以被每个单位通过。每个网格单元可以是<strong>open</strong>的，表示一个单位可以通过，也可以是<strong>blocked</strong>的，表示该单元无法通过。  </p>
<h2 id="流场"><a href="#流场" class="headerlink" title="流场"></a>流场</h2><p>单位依照静态矢量流场在网格中移动。<strong>流场</strong>表示网格中每个单元的最佳路径方向，是连续流函数的近似值。对于给定的一组目的点，流函数定义了一个归一化向量的向量场，表示到最近目的点的最佳路径方向。流函数类似于流体动力学中描述流动的常用方法，不同之处在于所有的流向量都是归一化的。鉴于这个定义，我们可以将流场定义为流函数的离散。<br>流场以与标准寻路系统相同的方式引导单位到达最近的目的地；然而，单位的路径信息被记录在流场中，消除了单位单独计算路径的需要。<br>流场是针对每一个潜在目的点集的，因此可以被所有共享一组目的地点的单位使用。由于流场表述的是整个游戏世界的路径信息，所以除非网格的可通行区域或目的点集合发生变化，否则它不需要更新。<br>例如，如果一座横跨河流的桥被摧毁了，那么流场只需要重新计算一次，以说明可通行区域的变化。跟随该流场的单位将根据游戏世界的变化而隐性地改变各自的路径。<br>流场由每个网格单元的单个归一化向量组成。一个流场和一组唯一的目的点一起称为<strong>路径</strong>。例如，对应于m乘n网格的路径是一组m*n个归一化向量和一组一个或多个目的点构成的点集。由于表示流函数所需的向量数量，这种方法可能会产生极高的内存使用率。内存消耗与网格单元数和独立路径数的乘积呈线性关系。Fieldrunners 2中的地图最多限制为三个唯一的路径，而且地图网格大小足够小，因此流场内存使用量并不是一个重要问题。<br>网格大小以及流场的分辨率并不需要很高，就能产生可信的运动特征。使用双线性插值，一个连续的流动函数可以从低分辨率流场中的四个最接近的向量中得到近似值。随着网格分辨率的增加，流场计算同一流函数的采样率越来越高。流场中矢量的双线性插值可以提高单位路径的连续性。  </p>
<h2 id="流场的生成"><a href="#流场的生成" class="headerlink" title="流场的生成"></a>流场的生成</h2><p>流场是通过修改后的传统点对点寻路函数生成的。Fieldrunners 2中使用的算法是Dijkstra，但是，其他的寻路算法也能够生成流场。<br>Fieldrunners 2中使用的算法首先将每条路径的目的地的网格单元添加到开放列表中。随着Dijkstra算法的正常迭代，节点从开放列表中移除，并链接到附近计算出路径成本最低的单元格。当开放列表中的单元格被扩展时，新扩展的单元格的流向量被设置为指向它被链接到的单元格的方向。该算法不是在找到路径时终止，而是扩展所有添加到开放列表中的可通行单元格，为每个单元格分配一个流向量，并在开放列表为空时终止。<br>每当路径的目标集或网格的可遍历区域发生变化时，前面的算法就会为每个路径生成一个流场。  </p>
<h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><p>Fieldrunners 2需要一个能够支持几十个不同单位的人群动力学系统，每个单位都有独特的运动特性。Fieldrunners 2中的单位是基于Boid模型的简单智能体。每个单位都有一组物理属性，和操纵行为共同控制其运动。单位的物理属性（如质量、大小，敏捷）定义了它独特的移动特性。<br>一个单位的操纵行为通过对其施加一组力来控制。这些转向力的优先组合会给单位施加一个加速度，从而实现真实的、可感知的智能运动。操纵行为在游戏中被广泛用于控制单位运动，并在许多出版物中进行了描述（例如《游戏人工智能编程案例精粹》,<a href="https://tmc0210.github.io/%E3%80%8A%E6%B8%B8%E6%88%8F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B%E7%B2%BE%E7%B2%B9%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">这里</a>是我的学习笔记）。在《Fieldrunners 2》中，作者对一些操纵行为的标准实现进行了修改，以支持更多的动态单元交互。</p>
<h3 id="操纵行为"><a href="#操纵行为" class="headerlink" title="操纵行为"></a>操纵行为</h3><p>Fieldrunners 2中的单元使用了五种操纵行为。这五种行为按优先级降序排列，包括<strong>流场跟随</strong>（flow-field following）、<strong>避障</strong>（obstacle avoidance）、<strong>分离</strong>（separation）、<strong>队列</strong>（alignment）和<strong>聚集</strong>（cohesion）。在每个模拟步骤中，一个单元只受指定的转向力总大小的影响。操纵行为所产生的力按优先顺序加入到运行的总量中，并截断到最大值。其他任何未被添加到总量中的转向力都被忽略。也即带优先级的加权截断累计。  </p>
<ul>
<li>其中分离、队列和聚集共同描述了集群行为。集群行为用于使单位在靠近其他单位时，以群体的形式凝聚移动。  </li>
<li>避障帮助速度较快的单位智能地绕过速度较慢的单位进行机动。避障操纵行为会产生一个垂直于单元速度的 “side stepping “力，并与邻近单元的位置和相对速度成比例。原始实现由于是考虑静态障碍，并不会考虑障碍的速度。  </li>
<li>分离操纵行为产生的力是由邻近单元的动能与受力单元的动能之比来衡量的。质量和速度较小的单位（也即更灵活）将更容易让步于较大的，机动性较差的单位。原始实现则只与距离和方向有关。  </li>
<li>流场跟随使单元按流场指定的方向移动。通过对四个最接近的流向量进行线性插值，计算出单元位置的流场方向。</li>
</ul>
<p>于是，质量、最大截断力、最大速度和邻接半径属性描述了一个单位的独特行为。</p>
<ul>
<li>质量用于计算操纵行为产生的加速度，和单位的动能。</li>
<li>最大截断力决定了在一个模拟步骤中可以影响单元的最大转向力。同时，单元的敏捷度被定义为单元的最大截断力与其质量的比值–单元的最大加速度。</li>
<li>最大速度属性限制了单元的速度大小。</li>
<li>邻接半径属性则限制了计算集群行为时考虑的半径。</li>
</ul>
<h3 id="校正单位的移动"><a href="#校正单位的移动" class="headerlink" title="校正单位的移动"></a>校正单位的移动</h3><p>我们有必要为每一个单位找到正确的属性值集，以产生期望的行为。在基于操纵行为的模拟中，这是非常困难的。设计者开发并使用了一种系统的校正参数方法来平衡Fieldrunners 2中的单位属性值集。为了简单起见，所有单位都使用了一套相同的加权的、先验的操纵行为，依靠它们的物理属性来实现独特的行为。以下为可参考的校正方法：    </p>
<ol>
<li>将最大速度属性设置为一个合理的值，其余的属性则给出一个任意的基础值。因为一个单元的最大速度最容易可视化，它提供了一个很好的调整起点。  </li>
<li>调整最大截断力，以产生该类型单位的可信运动特征。因为最大截断力会影响单位的敏捷度，它将改变视觉方面，如转弯速度和制动能力。  </li>
<li>给定一组同质的单位，单位邻接半径属性的变化结果可以很容易地单独观察。较小的邻接半径将使单元更紧密地聚集在一起，而增加邻接半径将使单元分散开来。  </li>
<li>所有单元的质量都是相对调整的。注意当调整单位的质量时，其敏捷度必须保持不变，否则之前调整过的单位的移动特性就会改变。</li>
</ol>
<h2 id="移动设备的限制与性能考察"><a href="#移动设备的限制与性能考察" class="headerlink" title="移动设备的限制与性能考察"></a>移动设备的限制与性能考察</h2><p>这种方法中最大的运行时性能问题是用于计算集群转向力的相邻单位列表的生成和处理。在Fieldrunners 2中，通过使用松散的四叉树来减少相邻单元搜索空间，性能问题得到了缓解。<br>移动处理器上的浮点运算可能会很慢，尽量减少路径和运动计算所需的运算次数也能带来改进。在Fieldrunners 2中，存储向量模的平方是一个常见的优化。这使得向量长度比较可以使用向量模的平方，消除了计算许多浮点平方根值的需要。<br>当大量单位需要导航到一组共同目标时，基于流场的系统提供了最大的好处。单位间每一个独特的目标位置集都需要一个单独的流场。随着独特的目标集数量的增加，维持必要的流场所需的计算和内存会变得非常复杂和庞大。表示流场所需的内存随着网格单元数的增加而线性增长，而寻路计算复杂度相当于所使用的寻路算法的最坏情况复杂度。在Fieldrunners 2的情况下，使用了Dijkstra算法，其产生的准线性时间复杂度取决于网格单元的数量。最小化流场内存消耗的一种方法是将流向量保存为 “北 “向量（通常为&lt;0,1&gt;）的特定旋转。当访问一个给定单元的流向时，已知的基础向量被重新创建并旋转到该单元的特定数量。另外，如果流向量恰好在特定的方向(例如，向量的基)，它们可以被存储为一个字节整数，其中的值对应于特定的方向。<br>随着移动硬件向多核处理器发展，正确利用多线程算法变得非常重要。产生多个流场的问题很容易被建模为一个并行过程。流场的相互独立性使得每个流场可以与其他流场并行计算，可能在不同的线程或进程中进行。操纵行为的组成和独立性使得它们也可以并行计算，只要它们被累积起来并集体应用到单元中。流场生成和操纵行为计算的内在并行性使得多线程本身的优化变得微不足道。</p>
<h2 id="优势与改进"><a href="#优势与改进" class="headerlink" title="优势与改进"></a>优势与改进</h2><p>在《Fieldrunners 2》中选择了这种单位移动方式，是因为它提供了一系列独特的好处。流场域中预先计算并存储了路径信息，因此对于一个给定的世界配置，它只计算一次。流场域的这一特性在《Fieldrunners 2》中提供了显著的性能优势，因为世界的路径不经常被修改。<br>世界中所有位置的寻路信息都是一次性计算的，产生了与Dijkstra算法相当的基于网格大小的复杂度。传统的寻路方法的时间复杂度与单位数量呈线性关系，而这种方法的时间复杂度与模拟的单位数量呈线性关系。对于《Fieldrunners 2》来说，这使得具有数千个独立和多样化单元的复杂场景能够以较高的帧率在移动设备上运行。<br>像这种基于操纵行为的方法在定义独特的单元行为方面提供了极大的灵活性。操纵行为依靠单位的属性值集来定义复杂的行为，有利于模块化和封装化。新的操纵行为的属性值集或对现有操纵行为的修改都可以很容易地应用到单位中，以定义独特的运动风格。<br>基于流场的寻路技术提供了一种独特的方式，通过计算每个点的最佳路径来减少冗余的寻路计算。出于简单，Fieldrunners 2中使用的流场生成技术是基于Dijkstra算法的。更先进的寻路算法，如Theta*，可以生成更平滑的流场。流场还可以通过混合静态和动态流场来扩展。尽管有这些潜在的改进，但静态流场和操纵行为还是为Fieldrunners 2提供了一个高鲁棒性、真实的人群模拟。  </p>
]]></content>
      <categories>
        <category>《Game AI Pro》</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>《Game AI Pro》 高斯随机、过滤随机与柏林噪声</title>
    <url>/2020/07/10/%E3%80%8AGAP%E3%80%8B%E9%AB%98%E6%96%AF%E9%9A%8F%E6%9C%BA%E3%80%81%E8%BF%87%E6%BB%A4%E9%9A%8F%E6%9C%BA%E4%B8%8E%E6%9F%8F%E6%9E%97%E5%99%AA%E5%A3%B0/</url>
    <content><![CDATA[<p>关于《Game AI Pro》 Advanced Randomness Techniques for Game AI:  Gaussian Randomness, Filtered Randomness, and Perlin Noise 的学习笔记。主要是三种随机的简介。  </p>
<span id="more"></span>
<h2 id="高斯随机"><a href="#高斯随机" class="headerlink" title="高斯随机"></a>高斯随机</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>高斯分布广泛存在于我们的身边。学生的身高、体重、成绩等变量都遵循高斯分布。当我们需要随机生成这一类变量时，简单地使用我们熟悉的均匀随机rand()是不符合要求的。这时我们就需要利用高斯随机生成符合高斯分布的随机数。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>虽然高斯分布的表达式非常复杂，但是实现高斯随机非常简单。由于中心极限定理，受到多个互为加性的均匀随机因素影响的随机变量即符合高斯分布。例如，掷出三个骰子，它们的和便遵循高斯分布。这个和受到三个骰子各自的均匀分布且具有加性的点数影响，所以为高斯分布。<br><img data-src="https://i.loli.net/2020/07/10/sypH4KwFxAnrTU3.png" alt="截屏2020-07-10 下午5.33.16.png"><br>具体实现中，我们可以类似地生成近似的高斯随机，将几个rand()生成的均匀随机变量加起来即可。例如将三个[-1，1]的均匀随机变量相加，得到的即为分布在[-3，3]中的高斯随机，且标准差σ为1，均值μ为0。其中100%落在 [μ-3σ，μ+3σ] 即 [-3，3] 中，95.8%落在 [μ-2σ，μ+2σ] 即 [-2，2] 中，66.7%落在 [μ-σ，μ+σ] 即 [-1，1] 中。在更为精确的模拟中可能需要模拟落在三倍标准差以外的小概率事件，但是游戏中通常不需要。  </p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>高斯随机最经典的用途之一是弹道偏移。大部分fps游戏中都需要模拟弹道偏移以增添真实感，而在弹道偏移量上简单地使用均匀随机得到的效果并不好。如果使用均匀随机，角色打靶的弹痕将均匀分布在靶心附近的一个圆上，圆的大小取决于均匀随机的范围，看起来并不真实。合理的方案是先使用均匀随机得到一个偏移的方向，再在这个方向上使用高斯随机得到偏移的距离。这样角色打靶的弹痕分布将在靶心较为密集，边缘较为稀疏，符合常识。</p>
<h2 id="过滤随机"><a href="#过滤随机" class="headerlink" title="过滤随机"></a>过滤随机</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>小样本的随机事件看起来并不随机。当玩家发现自己被敌人连续暴击三次击杀时，玩家最先想到的通常并非“敌人的暴击率为30%，我被连续暴击三次的概率为2.7%，还算正常”，而是“这破游戏针对我，退坑！”。为避免这种玩家莫名流失的情形，便可以采用过滤随机，“修复”这一“bug”。  </p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>过滤随机的实现更为简单，只需在生成随机数时存储最后生成的一段数列，生成最新一项时进行检查，出现一些引发玩家迷惑的组合时考虑重新随机或调整。以下为一些示例</p>
<h4 id="掷硬币"><a href="#掷硬币" class="headerlink" title="掷硬币"></a>掷硬币</h4><ul>
<li>如果最新的值会导致连续的四个或更多相同值，75%的概率翻转该值。</li>
<li>如果最新的值导致出现了四个值的重复排列，例如11001100，翻转该值（即变为11001101）</li>
<li>如果最新的值导致出现了111000或000111，翻转该值<br>示例<br>过滤前：0 1 1 0 1 1 0 0 0 0 1 1 0 0 0 0 1 0 1 0 0 0 0 0 0 1 0 0 1 0 1 1 1 1 0 0 1 1 1 0 0 1 1 1 0 0 0 1 1 0<br>过滤后：0 1 1 0 1 1 0 0 0 1 1 0 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 1 1 1 0 0 1 1 1 0 0 1 1 1 0 0 1 1 1 0</li>
</ul>
<h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><ul>
<li>出现连续数字，例如 7，7</li>
<li>出现连续数字被另一数字隔断，例如 8，3，8</li>
<li>出现4个或更多递增或递减的数字，例如 3，4，5，6</li>
<li>最后若干个数均较大或均较小，例如 6，8，7，9，8，6，9</li>
<li>两个数字的组合在最后十位重复出现，例如 5，7，3，1，5，7</li>
<li>某一数字在最后十位出现次数过多，例如 9，4，5，9，7，8，9，0，2，9</li>
</ul>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>以[0，1]为例</p>
<ul>
<li>连续两个数差小于0.02，重新随机，例如0.875和0.856</li>
<li>连续三个数差小于0.1，重新随机，例如0.345，0.421，0.387</li>
<li>5个数连续递增或递减，重新随机，例如0.342，0.572，0.619，0.783，0.868</li>
<li>最后若干个数均较大或均较小，重新随机，例如0.325，0.198，0.056，0.432，0.216</li>
</ul>
<h4 id="高斯随机-1"><a href="#高斯随机-1" class="headerlink" title="高斯随机"></a>高斯随机</h4><p>由于高斯随机与浮点数随机较为相似，上述的规则仍然可以沿用。除此之外，如下规则也可作为参考</p>
<ul>
<li>连续四个数均靠近或均远离0</li>
<li>连续四个数位于2σ与3σ之间</li>
<li>连续两个数位于3σ之外</li>
</ul>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p>以上的一些策略仅为示例，这并不意味着需要在游戏中使用类似的所有策略。事实上，上述的策略可能过于严苛以至于破坏游戏中随机数的数学完整性。在使用过滤随机时，我们需要仔细思考规则，还可以使用开源程序ENT测试规则下生成的随机数的随机程度。<br>现在的网游中暴击、抽卡、开箱等事件通常使用更复杂的随机策略。例如假设玩家的暴击率为5%，则第一次击中的暴击率将低于5%。随着连续击中而没有触发暴击，玩家的暴击率逐步上升，在第20次时达到100%。如果中途触发暴击，则暴击率将还原至初始值。这需要设计一条概率曲线，它的增长幅度合理且最终总的暴击率仍为5%。如果概率曲线设计合理，这种策略将使得暴击的触发更为分散，也符合广大玩家“暴击率5%意味着20次必暴击一次”的认知。开箱中的“幸运值”，“保底”等机制也类似如此。</p>
<h2 id="柏林噪声"><a href="#柏林噪声" class="headerlink" title="柏林噪声"></a>柏林噪声</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>柏林噪声通常被用来产生平滑的随机，例如生成起伏的地表，平滑的随机移动，游戏角色的心情变化。一维的柏林噪声即可生成2d地图中的地表，生成类似我的世界的游戏地形则需要二维的柏林噪声。一维柏林噪声大概长下图这样。<br><img data-src="https://i.loli.net/2020/07/10/4lN8gvXL2yYiGWD.png" alt="一维柏林噪声"></p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>实现柏林噪声，我们需要得到一条随机的平滑曲线。对于一条简单的随机曲线，我们可以使用随机数与插值得到，但是这样的曲线过于单调，不满足我们的使用要求。这时，我们可以将一些曲线叠加在一起，得到更具有变化性的曲线。<br>为了叠加曲线，首先我们需要引入<strong>倍频</strong>（octave）和<strong>持续度</strong>（Persistence）两个概念。在生成之前，我们需要选择你的柏林噪声使用几个倍频，这取决于你的精度要求和性能。倍频决定了你的柏林噪声由几个基本曲线合成，以及这些曲线的频率和振幅。其中倍频为n的曲线的振幅为持续度的n次方，而频率为2的n次方。例如如果取倍频为4，持续度为0.5，则我们便要将倍频为1，2，3，4的生成曲线分别乘以0.5的1，2，3，4次方并相加得到最终的柏林噪声，其中倍频为1，2，3，4的生成曲线频率分别为1，2，4，8倍。<br>那么每一个倍频的曲线该如何生成呢？此处以横纵坐标上限均为1，倍频为4，持续度为0.5为例。对于倍频1的曲线，我们只需要在[0，1]中随机取起点和终点的值，使用缓和函数插值即可。最早的缓和函数为3t<sup>2</sup> - 2t<sup>3</sup> 后来被改进为现在通常使用的6t<sup>5</sup> - 15t<sup>4</sup> + 10t<sup>3</sup>，因为这一函数的二阶导连续。而更高倍频的只需如法炮制，不同的是倍频越高，为使频率能够翻倍就需要额外取一些随机数作为插值的依据。其中，倍频1使用2个随机数，倍频2使用3个随机数，倍频3使用5个随机数，其规律为2<sup>n - 1</sup> + 1，当然这些随机数都需要间距相等。<br>生成完毕后，便可以合成为所需的柏林噪声曲线。下图即为一个示例。<br><img data-src="https://i.loli.net/2020/07/10/EAQqjkFrnayzBvH.png" alt="截屏2020-07-10 下午10.42.16.png"></p>
<h3 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h3><p>柏林噪声在图形学上也有许多应用，可以用于生成火焰，熔岩，大理石等纹理，有许多可以深入研究的地方。这里仅为对文章内容的简单总结，如需更深入了解在图形学上的应用，可以阅读<a href="https://blog.csdn.net/candycat1992/article/details/50346469">这篇文章</a>。</p>
]]></content>
      <categories>
        <category>《Game AI Pro》</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>《游戏人工智能编程案例精粹》学习笔记（一）</title>
    <url>/2020/07/02/%E3%80%8A%E6%B8%B8%E6%88%8F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B%E7%B2%BE%E7%B2%B9%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>关于《游戏人工智能编程案例精粹》的学习笔记。本节主要是智能体的行为与极简的图算法介绍。</p>
<span id="more"></span>

<h2 id="自治的可移动游戏智能体"><a href="#自治的可移动游戏智能体" class="headerlink" title="自治的可移动游戏智能体"></a>自治的可移动游戏智能体</h2><blockquote>
<p>一个自治智能体是这样一个系统，它位于一个环境的内部，是环境的一部分，且能感知该环境对它有效实施的作用，并永远按此进行，为未来的新感知提供条件。  </p>
</blockquote>
<p><del>也就是一个随机应变的会动的玩意</del><br>这里主要谈到了智能体的以下一些行为思路  </p>
<h3 id="操控行为"><a href="#操控行为" class="headerlink" title="操控行为"></a>操控行为</h3><h4 id="Seek（靠近）"><a href="#Seek（靠近）" class="headerlink" title="Seek（靠近）"></a>Seek（靠近）</h4><p>也就是直线靠近目标，直接以坐标的差作为速度的方向</p>
<h4 id="Flee（离开）"><a href="#Flee（离开）" class="headerlink" title="Flee（离开）"></a>Flee（离开）</h4><p>与Seek相反，远离目标，略</p>
<h4 id="Arrive（抵达）"><a href="#Arrive（抵达）" class="headerlink" title="Arrive（抵达）"></a>Arrive（抵达）</h4><p>Seek在实际移动中可能会出现一些问题，例如速度较大导致不断来回穿过目标而无法停止。这时可以使用arrive，也即智能体慢慢减速直到停在目标的位置。</p>
<h4 id="Pursuit（追逐）"><a href="#Pursuit（追逐）" class="headerlink" title="Pursuit（追逐）"></a>Pursuit（追逐）</h4><p>当智能体需要拦截一个会移动的目标的时候，pursuit就较为合适。pursuit也就是预判目标的走位，根据目标的当前速度预估对方在未来某个时间的位置，并向这个目标前进。有以下几个需要注意的点。  </p>
<ul>
<li>当智能体正对逃避者时，也即两者几乎速度方向相反时（例如夹角小于20度），可以退化为seek。  </li>
<li>需要对预测的时间作出较好的折衷以平衡效率和准确度。例如使预测时间正比于逃避者和追逐者的距离，反比于两者速度的差。  </li>
<li>一些运动模型需要考虑使智能体转向偏移位置的时间，这时可以为预测时间加上一个正比于朝向向量的点积和最大转弯率的值来实现。</li>
</ul>
<p><img data-src="https://i.loli.net/2020/07/02/SOARyHLgiKehcZ3.png" alt="追逐"></p>
<h4 id="Evade（逃避）"><a href="#Evade（逃避）" class="headerlink" title="Evade（逃避）"></a>Evade（逃避）</h4><p>与pursuit完全相反，但是不需要检查面向方向。</p>
<h4 id="Wander（徘徊）"><a href="#Wander（徘徊）" class="headerlink" title="Wander（徘徊）"></a>Wander（徘徊）</h4><p>使智能体在环境中随机走动。一个简单但不可行的做法是每帧计算出一个随机的速度，这会使得物体在场景中抖动而非平滑转弯。为使物体平滑转弯，可以使用Perlin噪声代替简单的随机数，虽然消耗过大但并非完全不可行。<br>书中介绍的方案来自Reynolds，在智能体的前端放置一个圆形，将一个目标限制在圆形上，每帧对这个目标添加一个随机位移，智能体再向这个随机目标移动。控制圆形的半径、圆心离智能体的距离、目标的随机位移大小就能得到不同风格的随机运动。  </p>
<blockquote>
<p>三维空间时将圆形改为球体即可类似地解决问题  </p>
</blockquote>
<p><img data-src="https://i.loli.net/2020/07/02/Vy6ksvulb5foWxE.png" alt="徘徊"></p>
<h4 id="Obstacle-Avoidance（避开障碍）"><a href="#Obstacle-Avoidance（避开障碍）" class="headerlink" title="Obstacle Avoidance（避开障碍）"></a>Obstacle Avoidance（避开障碍）</h4><p>控制智能体避开障碍物。这里的思路是从智能体衍生出一个长方形区域碰撞器，其宽度等同于智能体的包围半径，衍生出的长度正比于当前速度。寻找这个碰撞器与前方障碍物的交点，如果有障碍物与这个碰撞器的侧面碰撞，说明继续前进会擦到障碍物，可以施加一个大小正比于交通工具到障碍物的距离，方向垂直于运动方向的力使智能体偏转。若有需要，可以同时让智能体减速，力的大小同样可以正比于交通工具到障碍物的距离。</p>
<blockquote>
<p>三维空间中，类似地替换为圆柱体即可  </p>
</blockquote>
<p><img data-src="https://i.loli.net/2020/07/02/yCZXrxYl872eAuK.png" alt="避开障碍"></p>
<h4 id="Wall-Avoidance（避开墙）"><a href="#Wall-Avoidance（避开墙）" class="headerlink" title="Wall Avoidance（避开墙）"></a>Wall Avoidance（避开墙）</h4><p>控制智能体避开近似为线段的墙。思路与上面类似，向前方伸出一个更为狭窄的长方形碰撞器检测是否撞到墙。可能的优化是可以向侧前方另外伸出两个较短的长方形碰撞器检测是否侧前方撞到墙，这取决于最后需要的行为精度。</p>
<h4 id="Interpose（插入）"><a href="#Interpose（插入）" class="headerlink" title="Interpose（插入）"></a>Interpose（插入）</h4><p>操控智能体移动到两个智能体或空间中点的中点，例如运动员截球。类似pursuit，需要估算两个目标在一段时间后的中点位置，朝向该位置arrive。这里的关键同样在于时间的预计。书中介绍的时间取值为智能体到当前两个目标的中点所需的时间，以这个时间估算未来的位置（芝诺悖论既视感  </p>
<p><img data-src="https://i.loli.net/2020/07/02/JLQTvokCIa7K2yW.png" alt="插入"></p>
<h4 id="Hide（隐藏）"><a href="#Hide（隐藏）" class="headerlink" title="Hide（隐藏）"></a>Hide（隐藏）</h4><p>hide行为旨在找到一个位置使得障碍物始终位于它和它想要躲避的另一智能体之间。适用于npc在开火时寻找掩体。具体实现可以先为附近的每个障碍物依据追逐者与障碍物的位置关系得到一个合适的隐藏点。例如圆形障碍物的隐藏点就位于追逐者与圆心的连线延长线上。再使用arrive抵达最近的隐藏点。如果附近没有合适的障碍物，退化为evade。如果需要实现智能体看见追逐者才会隐藏，可以在简单实现的基础上加入记忆功能。例如如果智能体可以看到目标或在最近几秒看到过目标，智能体将隐藏。  </p>
<p><img data-src="https://i.loli.net/2020/07/03/uU7bx3PdtcDZjMN.png" alt="隐藏"></p>
<h4 id="Path-Following（路径跟随）"><a href="#Path-Following（路径跟随）" class="headerlink" title="Path Following（路径跟随）"></a>Path Following（路径跟随）</h4><p>使智能体沿着预先设置的一系列路点移动。实现思路较为简单，略。</p>
<h4 id="Offset-Pursuit（保持一定偏移的追逐）"><a href="#Offset-Pursuit（保持一定偏移的追逐）" class="headerlink" title="Offset Pursuit（保持一定偏移的追逐）"></a>Offset Pursuit（保持一定偏移的追逐）</h4><p>保持与领队相对位置不变的情况下追逐领队，实现类似大雁列队飞行、战斗组队的效果。首先得到要求的相对位置偏移，之后计算追逐时不直接追逐领队，而是追逐领队偏移后的相对位置。注意使用arrive而非seek使编队有序。</p>
<h3 id="组行为"><a href="#组行为" class="headerlink" title="组行为"></a>组行为</h3><p><img data-src="https://i.loli.net/2020/07/03/GqCsNBXO9ZeWtAd.png" alt="组行为">  </p>
<h4 id="Separation（分离）"><a href="#Separation（分离）" class="headerlink" title="Separation（分离）"></a>Separation（分离）</h4><p>操作智能体离开邻近的智能体，应用在许多智能体上将会使它们向四周展开，拉开距离。这里的实现是遍历附近的所有智能体，对每个邻近智能体，得到一个大小反比于距离，方向为互相远离的力，以这些力的合力作为智能体的最终运动参考。</p>
<h4 id="Alignment（队列）"><a href="#Alignment（队列）" class="headerlink" title="Alignment（队列）"></a>Alignment（队列）</h4><p>保持一组智能体的朝向一致。迭代附近的所有智能体，得到一个平均的朝向向量，减去该智能体的朝向即可得到力的方向</p>
<h4 id="Cohesion（聚集）"><a href="#Cohesion（聚集）" class="headerlink" title="Cohesion（聚集）"></a>Cohesion（聚集）</h4><p>使智能体移向邻近智能体的质心。</p>
<h3 id="Combining-Steering-Behaviors（组合操控行为）"><a href="#Combining-Steering-Behaviors（组合操控行为）" class="headerlink" title="Combining Steering Behaviors（组合操控行为）"></a>Combining Steering Behaviors（组合操控行为）</h3><p>当物体可能同时处于上述多个行为的状况中时（例如在列队前行的同时避免撞墙），就需要对这些力进行综合的计算，考虑到消耗和精确度，有以下几种方案。</p>
<h4 id="加权截断总和"><a href="#加权截断总和" class="headerlink" title="加权截断总和"></a>加权截断总和</h4><p>对每个行为设定一个初始的权值，将它们分别计算得到的力乘以权值后相加，再截断到最大可操控力。这里的问题是每帧需要计算所有的行为，消耗较大，而且权值难以设计。</p>
<h4 id="带优先级的加权截断累计"><a href="#带优先级的加权截断累计" class="headerlink" title="带优先级的加权截断累计"></a>带优先级的加权截断累计</h4><p>计算出一个带优先级的加权的累计，再进行截断。这里不再为行为设定权值，而是设定优先级，例如避开障碍物比保持队形重要。这个方法迭代每一个可行的行为，计算力的总和。每次计算合力的累计后如果还有剩余的可操纵力，继续计算下一个优先级的力，如果没有剩余或已超出最大可操纵力，截断。</p>
<h4 id="带优先级的抖动"><a href="#带优先级的抖动" class="headerlink" title="带优先级的抖动"></a>带优先级的抖动</h4><p>来自Reynolds的方法。该方法检查优先级的方法不固定，而是根据预设的概率，例如优先级较高的行为的力有0.9的概率被计算，而优先级较低的只有0.5。这一方案消耗较少但是会损失精确度。</p>
<h3 id="平滑"><a href="#平滑" class="headerlink" title="平滑"></a>平滑</h3><p>当智能体的不同行为有冲突时，可能会发生一些抖动，这里有一个方案是分离朝向向量和速度向量，通过若干次更新变量步骤得到朝向向量的平均值。</p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="盲目搜索"><a href="#盲目搜索" class="headerlink" title="盲目搜索"></a>盲目搜索</h3><p>盲目搜索在搜索一个图时不考虑相关的边的开销，但是它们能区分不同的节点和边。为了遍历一个图或是找到两个点之间的路径，可以使用这些方法，例如大家熟知的DFS和BFS。</p>
<h3 id="基于开销的图搜索"><a href="#基于开销的图搜索" class="headerlink" title="基于开销的图搜索"></a>基于开销的图搜索</h3><p>考虑到边的权值的搜索。可以采用Dijkstra或是A*算法。<del>因为我不怎么会所以不展开</del> </p>
<h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><p>Dijkstra算法每次构建SPT（最短路径树）的一条边，简要介绍思路如下  </p>
<ul>
<li>源节点加入SPT</li>
<li>从源节点出发的几条边加入搜索边界</li>
<li>检查搜索边界指向的所有节点，将其中距离源节点最近的节点加入SPT，接下来从该点出发的边加入搜索边界</li>
<li>如此往复直到完成</li>
</ul>
<p>这样得到的SPT将包含找到的每一个节点的最短路径  </p>
<h4 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h4><p>Dijkstra算法的一个改进，加入了启发因子（Heuristic）。对于边界上的点的开销计算，使用被修正的开销 F 而非简单的离源节点距离决定节点在优先队列中的位置：  </p>
<center>F = G + H</center>  

<p>其中，G 为累计开销，H为启发因子，给出的是节点到目标节点的估计距离。常用的有欧几里得距离和曼哈顿距离。</p>
]]></content>
      <categories>
        <category>《游戏人工智能编程案例精粹》</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>《游戏人工智能编程案例精粹》学习笔记（三）</title>
    <url>/2020/07/08/%E3%80%8A%E6%B8%B8%E6%88%8F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B%E7%B2%BE%E7%B2%B9%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>关于《游戏人工智能编程案例精粹》的学习笔记。本节主要是模糊集合的介绍以及模糊逻辑的应用。</p>
<span id="more"></span>

<h2 id="模糊集合"><a href="#模糊集合" class="headerlink" title="模糊集合"></a>模糊集合</h2><p>普通集合适用于一些非黑即白的情况，而实际情况通常有一些模棱两可的情形需要考虑。这时就需要引入模糊集合，仅为引入模糊逻辑所需，不作过多展开。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>给定一个论域U，那么从U到单位区间 [0,1] 的一个映射 μ：U-&gt;[0,1] 称为U上的一个<strong>模糊集合</strong>，或U的一个模糊子集。  </p>
</blockquote>
<p>其中映射称为<strong>隶属函数</strong>，对于特定元素，该映射的值称为<strong>隶属度</strong>。通常简单的隶属函数为三角形或梯形。传统集合的隶属度则为0或1，也即属于或不属于。<br>这一概念由美国加利福尼亚大学控制论专家L.A.扎德于 1965 年率先提出，适用于我们熟悉的秃头悖论等玄学问题。</p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>设A与B是同一论域U上的两个模糊集合。</p>
<p>模糊集合的包含：  </p>
<center>A ⊂ B 即 μ<sub>A</sub>(u) ≤ μ<sub>B</sub>(u) ∀ u ∈ U</center>  
模糊集合的等于：  
<center>A = B 即 μ<sub>A</sub>(u) = μ<sub>B</sub>(u) ∀ u ∈ U</center> 
模糊集合的并集运算：  
<center>μ<sub>A ∪ B</sub>(u) = max { μ<sub>A</sub>(u) , μ<sub>B</sub>(u) }</center>  
模糊集合的交集运算：  
<center>μ<sub>A ∩ B</sub>(u) = min { μ<sub>A</sub>(u) , μ<sub>B</sub>(u) }</center>  
模糊集合的补集运算：    
<center>μ<sub>A`</sub>(u) = 1 - μ<sub>A</sub>(u)</center>  

<h3 id="基本运算定律"><a href="#基本运算定律" class="headerlink" title="基本运算定律"></a>基本运算定律</h3><p>模糊集合的运算同样满足恒等律，交换律，结合律，分配律，吸收律，同一律，对偶律等定律，不同的是互补律不满足，也即：</p>
<center>A ∩ A` ≠ Ø </center>  
<center>A ∪ A` ≠ E </center>    
此处E为模糊全集，满足  
<center>μ<sub>E</sub>(u) = 1 ∀ u ∈ U</center>
Ø为模糊空集，满足
<center>μ<sub>Ø</sub>(u) = 0 ∀ u ∈ U</center>  

<h3 id="限制词"><a href="#限制词" class="headerlink" title="限制词"></a>限制词</h3><p>限制词是一元运算符，用于修饰模糊集合的含义，常用的修饰词例如“极”，“非常”，“略”，“稍微”。对于一个模糊集合来说，这些修饰词的含义通常为对模糊集合的隶属度函数取平方或开根号。<br>例如，如果定义模糊子集“老”的隶属度函数为μ<sub>老</sub>(u)，且修饰词的隶属度函数如下：  </p>
<center>μ<sub>极A</sub> = μ<sub>A</sub><sup>4</sup></center>  
<center>μ<sub>非常A</sub> = μ<sub>A</sub><sup>2</sup></center>  
<center>μ<sub>略A</sub> = μ<sub>A</sub><sup>0.5</sup></center>  
<center>μ<sub>稍微A</sub> = μ<sub>A</sub><sup>0.25</sup></center>  
则有  
<center>μ<sub>极老</sub>(u) = μ<sub>老</sub><sup>4</sup>(u)</center>  
<center>μ<sub>非常老</sub>(u) = μ<sub>老</sub><sup>2</sup>(u)</center>  
<center>μ<sub>略老</sub>(u) = μ<sub>老</sub><sup>0.5</sup>(u)</center>  
<center>μ<sub>稍微老</sub>(u) = μ<sub>老</sub><sup>0.25</sup>(u)</center>  
这是非常直观的，因为集合使用这些修饰词后，标准也就应当比原先更为宽松或严格。

<h3 id="模糊数"><a href="#模糊数" class="headerlink" title="模糊数"></a>模糊数</h3><p>连续论域U上的模糊数F是一个U上的正规凸模糊集合。其中正规指  </p>
<center>max μ<sub>F</sub>(u) = 1</center>  
凸集合指曲线上任意两点之间，曲线上的任意一点所表示的隶属度都大于或等于两点中隶属度较小的一个，也即
<center>μ<sub>F</sub>(x) ≥ min { μ<sub>F</sub>(a) , μ<sub>F</sub>(b) } ∀ a,b ∈ U x ∈ [a,b]</center>  

<h3 id="模糊语言变量"><a href="#模糊语言变量" class="headerlink" title="模糊语言变量"></a>模糊语言变量</h3><p>模糊语言变量（FLV）表示一个或多个模糊集合的合成，定量地表示一种概念或域。例如<br>目标朝向 &#x3D; { 远左，左，中，右，远右 }<br>它的隶属函数形状集合（或为模糊形，模糊表面）可以如下所示<br><img data-src="https://i.loli.net/2020/07/08/OSanT4vrHXkiAUD.png" alt="目标朝向">  </p>
<h2 id="掠夺者中的模糊逻辑"><a href="#掠夺者中的模糊逻辑" class="headerlink" title="掠夺者中的模糊逻辑"></a>掠夺者中的模糊逻辑</h2><p>了解完了基本概念，我们就可以看看如何在掠夺者中引入模糊集合来计算武器的期望分数。</p>
<h3 id="模糊规则"><a href="#模糊规则" class="headerlink" title="模糊规则"></a>模糊规则</h3><p>传统的判断可能是这样的：<br>如果 Wizard.Health ≤ 0 那么 Wizard.Die()<br>但是模糊规则不同。在模糊系统中，判断可能是这样的：<br>如果 敌人受伤<strong>非常</strong>严重 那么 敌人逃跑 </p>
<h3 id="为武器设计模糊语言变量"><a href="#为武器设计模糊语言变量" class="headerlink" title="为武器设计模糊语言变量"></a>为武器设计模糊语言变量</h3><p>设计模糊变量时，应当依据如下准则 </p>
<ul>
<li>通过模糊语言变量的任何垂直线，在每个与之相交的模糊集合的隶属度总和应为1。这保证了模糊形数值的平稳过渡。</li>
<li>通过模糊语言变量的任何垂直线，应当只与两个或更少的模糊集合相交。这保证了模糊形足够简单易用</li>
</ul>
<p>例如使用火箭炮这一武器的期望取决于与敌人的距离和弹药量，其中模糊集合如下图所示：<br><img data-src="https://i.loli.net/2020/07/08/ewmYKyvUt2VAOC5.png" alt="截屏2020-07-08 下午8.23.32.png"><br><img data-src="https://i.loli.net/2020/07/08/rmlBAc7YvbEyPGN.png" alt="截屏2020-07-08 下午8.23.39.png"><br><img data-src="https://i.loli.net/2020/07/08/pWNMSLAjXUKqt9i.png" alt="截屏2020-07-08 下午8.23.48.png"></p>
<h3 id="为武器设计模糊规则"><a href="#为武器设计模糊规则" class="headerlink" title="为武器设计模糊规则"></a>为武器设计模糊规则</h3><p>由于游戏中假想的火箭炮是一种爆炸范围较大，弹道较慢的武器，所以可以设计规则如下所示：  </p>
<ol>
<li>如果距离远且弹药超载，期望攻击</li>
<li>如果距离远且弹药合适，不期望攻击</li>
<li>如果距离远且弹药少，不期望攻击</li>
<li>如果距离中等且弹药超载，非常期望攻击</li>
<li>如果距离中等且弹药合适，非常期望攻击</li>
<li>如果距离中等且弹药少，期望攻击</li>
<li>如果距离近且弹药超载，不期望攻击</li>
<li>如果距离近且弹药合适，不期望攻击</li>
<li>如果距离近且弹药少，不期望攻击</li>
</ol>
<h3 id="模糊推理"><a href="#模糊推理" class="headerlink" title="模糊推理"></a>模糊推理</h3><p>引入这些花里胡哨的概念的目的在于根据这些模糊的规则与对应的隶属度函数，以一组输入得到一个确定的输出值。这一输出值即可作为期望分数，与其他武器的期望分数相比较，从而让AI角色选择合适的武器。于是，对于一组输入，我们需要以如下形式进行模糊推理：  </p>
<ul>
<li>对于每条规则，根据输入数据计算前提条件的隶属度</li>
<li>根据计算出的隶属度得到这一规则的推理结论隶属度</li>
<li>综合所有规则的结论，得到一个单一的结论</li>
<li>将结论去模糊化，得到期望分数</li>
</ul>
<p>例如：<br>设输入条件中距离为200，弹药为8。<br>对于规则1，查阅上面的模糊形可知，距离200对于<strong>距离远</strong>的隶属度为0.33，弹药8对于<strong>子弹超载</strong>的隶属度为0。“且”这一连接词告知我们需要计算隶属度的交集，也即取值为min {0，0.33} &#x3D; 0。所以这里规则1推导出的对<strong>期望攻击</strong>的隶属度为0。<br>类似地可以计算出，规则2推导出的对<strong>不期望攻击</strong>的隶属度为min {0.33,0.78} &#x3D; 0.33。以此类推进行计算，结果可以归纳为如下一个矩阵，也即<strong>模糊联想矩阵（FAM）</strong><br><img data-src="https://i.loli.net/2020/07/08/WuYZ1V3eDn7SFMK.png" alt="FAM.png"><br>接下来，我们需要为这一矩阵得到一个单一的模糊集合结论。<br>首先，我们需要处理矩阵中的多重置信度，也即对于同一结论的好几个不同的隶属度，这里有两种常用的方案</p>
<ul>
<li>取和并截断到最大值（也即1）</li>
<li>取最大值，也即“或”运算</li>
</ul>
<p>这里我们采用第二种方案。可以得到如下的计算结果</p>
<table>
<thead>
<tr>
<th>结论</th>
<th>置信度</th>
</tr>
</thead>
<tbody><tr>
<td>不期望攻击</td>
<td>0.33</td>
</tr>
<tr>
<td>期望攻击</td>
<td>0.2</td>
</tr>
<tr>
<td>非常期望攻击</td>
<td>0.67</td>
</tr>
<tr>
<td>接下来我们需要利用矩阵结果对原本的期望值模糊集合进行截断后合并处理。注意对比下图左侧的截断后结果与原本的期望值隶属度函数。</td>
<td></td>
</tr>
<tr>
<td><img data-src="https://i.loli.net/2020/07/08/gtPo7V2us5Xdhr4.png" alt="截断合并"></td>
<td></td>
</tr>
<tr>
<td>于是我们便得到了对应这组输入的新的模糊形。</td>
<td></td>
</tr>
<tr>
<td>最后一步是利用模糊形得到一个期望分数，也即去模糊化。这里有以下几种方案。</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>最大值均值（MOM）<br>  这种算法的思路是计算具有最高置信度输出值的平均值。例如对于上面的合成模糊形，在右侧梯形的上方取到最值。而右侧梯形的左上顶点为66，右上顶点为100，便得到最大值均值83，作为期望分数。<br>  这一方法的问题是为了效率抛弃了左侧的大量数据。  </p>
</li>
<li><p>中心法<br>  这是一种准确而复杂的方法。它的思路是通过采样大致确定模糊形的重心。其公式如下：<br>  <img data-src="https://i.loli.net/2020/07/08/QhPRO68eWZUJtAq.png" alt="中心法公式"><br>  其中，s是每个采样点的值，DOM(s)是对应的模糊语言变量的隶属度。显而易见，被取样值的越多，这一算法越准确。实践中通常使用10到20个采样点。<br>  例如对于上面的模糊语言变量，采样取10、20、30 …… 100，共计10个采样点。它们对应的隶属度分别为0.33、0.33、0.53、0.53、0.2、0.6、0.87、0.67、0.67、0.67（部分值为看图估计），故：<br>  Desirability &#x3D; （10 * 0.33 + 20 * 0.33 + …… + 100 * 0.67）&#x2F;（0.33 + 0.33 + …… + 0.67）<br>  也即 334.8&#x2F;5.4 &#x3D; 62  </p>
</li>
<li><p>最大值平均<br>  这一方法的计算较为简单，而且结果接近于中心法，适合使用于实际的项目之中。<br>  一个模糊集合的最大值或代表值也就是对这个集合的隶属度为1的值。对于梯形集合而言，这意味着上方两顶点的平均值，退化为三角形时结论自然变为三角形上顶点。<br>  最大值平均（MaxAv）去模糊方法的公式如下：<br>  <img data-src="https://i.loli.net/2020/07/08/CoP1NMjae3xtyTn.png" alt="最大值平均"><br>  对于上述模糊形，计算过程如下：<br>  首先得到各个集合的代表值</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>代表值</th>
<th>置信度</th>
</tr>
</thead>
<tbody><tr>
<td>不期望攻击</td>
<td>12.5</td>
<td>0.33</td>
</tr>
<tr>
<td>期望攻击</td>
<td>50</td>
<td>0.2</td>
</tr>
<tr>
<td>非常期望攻击</td>
<td>87.5</td>
<td>0.67</td>
</tr>
<tr>
<td>代入公式计算： Desirability &#x3D; （1.25 * 0.33 + 50 * 0.2 + 87.5 * 0.67）&#x2F;（0.33 + 0.2 + 0.67） &#x3D; 72.75 &#x2F; 1.2 &#x3D; 60.625</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<p>于是我们便利用模糊逻辑得到了所需的期望分数，计算不同武器的期望分数即可作为AI的选择依据。</p>
<h3 id="库博方法"><a href="#库博方法" class="headerlink" title="库博方法"></a>库博方法</h3><p>在看到上面定义的模糊规则时，你可能已经想到，仅仅是两条三种情况的模糊语言变量，却产生了3 * 3 &#x3D; 9条模糊规则。显而易见，模糊规则的数量会随着模糊语言变量的复杂度与数量飞速增加。幸运的是，库博方法可以解决这一问题。<br>库博方法通过拆解，使规则增加的速度降低为线性。其基于一个简单规则：<br>如果距离远且弹药超载，期望攻击 在逻辑上等价于<br>如果距离远，期望攻击<br>或 如果弹药超载，期望攻击<br>前述的9条规则在库博方法的简化后如下：  </p>
<ol>
<li>如果距离近，不期望攻击</li>
<li>如果距离中等，非常期望攻击</li>
<li>如果距离远，不期望攻击</li>
<li>如果弹药少，不期望攻击</li>
<li>如果弹药合适，期望攻击</li>
<li>如果弹药超载，非常期望攻击<br>这一简化的方法并不直观，甚至完全变换了原本的规则。但神奇的是仅需变换规则本身而不用改变其余部分，代码即可适用于库博规则，其得到的期望分数与传统的模糊逻辑推理程序十分类似。例如前述规则使用库博规则后得到的期望分数为57.16，近似于之前的60.625。</li>
</ol>
]]></content>
      <categories>
        <category>《游戏人工智能编程案例精粹》</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>《游戏人工智能编程案例精粹》学习笔记（二）</title>
    <url>/2020/07/07/%E3%80%8A%E6%B8%B8%E6%88%8F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B%E7%B2%BE%E7%B2%B9%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>关于《游戏人工智能编程案例精粹》的学习笔记。本节主要是《掠夺者》的概述，路径规划与目标驱动。</p>
<span id="more"></span>

<h2 id="《掠夺者》概述"><a href="#《掠夺者》概述" class="headerlink" title="《掠夺者》概述"></a>《掠夺者》概述</h2><p>这是书中的一个案例，基本玩法类似于2d吃鸡。其要求如下：  </p>
<ul>
<li><p>决策<br>AI需要制定游戏计划，长期目标，短期目标等。目标可以是攻击敌人、找到血包等。将目标与现有状态进行对比评估，从而作出决策。后面有单独章节介绍这一评估方式。</p>
</li>
<li><p>移动<br>AI需要综合使用上述的移动方式，使移动自然。主要使用的移动方式有Seek，Arrive，Wander，Wall Avoidance 和 Separation。  </p>
</li>
<li><p>路径规划<br>AI需要对于一个想要达成的目标，规划合适的路径去达成。后面有单独章节介绍完整的寻路</p>
</li>
<li><p>感知<br>AI需要模拟角色的视觉听觉以及记忆。如果不考虑角色的记忆而只是采用简单的视觉模拟感知，效果将大打折扣。想象一个情况，A的视野中有B，C两个敌人，A选择率先攻击B，于是转向B并发动攻击，这使得C消失在了视野中。于是消灭B后，A便不会回头攻击C，这显然是不合理的。所以可以为AI角色引入记忆功能，例如使用一个map存储上一次遇到各个敌人的时间，根据这个map对较近时候碰到的敌人作出反应。 </p>
</li>
<li><p>目标选择<br>AI需要选择合适的目标以发起攻击或追逐等操作，可以简单地以最近的敌人为目标，实际的开发可能需要综合考虑敌人的武器，生命等要素。</p>
</li>
<li><p>武器控制<br>AI需要根据敌人的距离等要素选择合适的武器进行攻击，例如近距离时不使用两败俱伤的爆炸性武器。不同武器也需要不同的瞄准方式，例如瞬发武器可以直接瞄准敌人当前位置，而弹道较慢的武器应当预判敌人的走位。另外，为保护玩家体验，可以加入进入视野到开始射击的反应时间以及射击的精度误差，此处误差建议为0～0.2弧度。武器控制的具体实现采用模糊逻辑。后面有单独章节介绍。</p>
<blockquote>
<p>tips</p>
<ul>
<li>对于某些游戏，AI对玩家的第一发子弹打偏是一个好主意，这可以提醒玩家AI的出现，使玩家做好准备。同时，如果能看到子弹的轨迹，这也能极大地提高游戏的刺激性  </li>
<li>当玩家生命值较低时，降低AI射击的精准度。这可以使玩家更频繁地达成死里逃生或绝地反杀，使游戏更加刺激。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="路径规划"><a href="#路径规划" class="headerlink" title="路径规划"></a>路径规划</h2><h3 id="导航图"><a href="#导航图" class="headerlink" title="导航图"></a>导航图</h3><p>为确定一条路径，游戏环境需要被分割为导航图，从而利用搜索算法对导航图进行搜索。常见的导航图有如下几种：</p>
<ul>
<li><p>单元<br>  基于正方形或六边形的单元导航图，每个图中的节点表示一个单元，图中的边表示相邻单元的连接。对于类似文明的游戏，每个单元通过的消耗不一，这可以为每个地图分配相应的地图信息，使用该信息为地图的边加权。<br>  这一方法的问题在于随着单元格的增加，导航图的节点和边也将急速增加。</p>
</li>
<li><p>可视点<br>  也即POV导航图，通常手工放置地图中的关键点并将它们连接起来。作为游戏中的导航图。<br>  如果地图较为庞大复杂导致手工填充地图过于耗时，或是有随机生成地图功能，就需要开发自动生成POV图的方法，例如下面的扩展图形。</p>
</li>
<li><p>扩展图形<br>  如果游戏环境由多边形构建，可以利用图形自带的信息去创建POV图。</p>
<ul>
<li>将多边形向外扩展一定的半径（略大于智能体半径）</li>
<li>把扩展出的图形的顶点作为导航图的节点</li>
<li>测试这些节点的可见性，得出导航图<br>  因为扩展了一定的半径，智能体便可以沿导航图自由通行而不撞到墙壁。</li>
</ul>
</li>
<li><p>导航网<br>  也即NavMesh，使用凸多边形描述游戏环境中的可访问区域。这里利用了凸多边形的重要性质：凸多边形的任意顶点可以互相直线到达。图的每个节点代表一个凸多边形区域而非一个点。</p>
</li>
</ul>
<h3 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h3><ul>
<li><p>粗粒度<br>  导航图较为简单，且只能沿导航图的边移动。类似吃豆人的游戏可以采取这种策略，但是需要任意导航的RTS游戏不适用。</p>
</li>
<li><p>细粒度<br>  增加导航图的粒度。细粒度导航图的生成通常使用洪水填充算法。</p>
<ul>
<li>将一个种子节点放入地图中</li>
<li>算法在每个节点的方向上向外扩展纳入图中</li>
<li>重复以上步骤，直到所有可以通航的区域都被填充满</li>
</ul>
</li>
</ul>
<h3 id="路径平滑"><a href="#路径平滑" class="headerlink" title="路径平滑"></a>路径平滑</h3><p>当游戏导航图是网状而实际游戏地图可以任意导航时，自动寻路创建的路径通常有额外的边。例如如下情况。  </p>
<p><img data-src="https://i.loli.net/2020/07/08/L3GD8fa5QwlUZpC.png" alt="路径图">  </p>
<p>A点试图到达C点，由于图的拓扑限制了45度的转向增量，寻路的结果可能是由A到B到C，但是实际游戏中需要从A到C直线前进，这时就需要对路径进行平滑处理。  </p>
<ul>
<li><p>粗糙而快地平滑路径<br>  算法按如下步骤执行  </p>
<ul>
<li>将两个迭代指针E1和E2放在第一条边和第二条边上。</li>
<li>如果E1的起点和E2的终点之间可直达（注意考虑智能体体积），说明E1和E2可被省略。在这两点之间连接一条新边，作为E1，将下一条边作为E2。</li>
<li>如果无法直达，则把E2赋给E1，并将E2指向路径中的下一条边。</li>
<li>重复以上步骤，直到E2的终点等于路径目的地。</li>
</ul>
</li>
<li><p>精确而慢地平滑路径<br>  每次E1向前移动，必须遍历从E1到最后一条边之间的所有边。这种方案较为精确但是显然消耗巨大。</p>
</li>
</ul>
<h3 id="降低消耗"><a href="#降低消耗" class="headerlink" title="降低消耗"></a>降低消耗</h3><ul>
<li><p>预先计算好的路径<br>  地图创建的同时，为地图创建一份查询表，查询表中包含每个节点到图中任意节点的路线。这可以用Dijkstra算法为每个节点创建一个最短路径树（SPT）以实现，并将SPT直接存储在一个二维整数数组中。<br>  查询表存储在二维整数数组的一个方式示例：<br>  节点0到节点5的最短路径的下一个节点是节点3，则将3存储在SPT[0][5]中，以此类推。</p>
</li>
<li><p>预先计算成本<br>  当考虑游戏中智能体的决策时，有时需要计算成本，例如移动所需的时间。如果对于每次决策都需要计算所有成本，那消耗将十分巨大。这时就需要一个计算好的成本表，这一创建方式与路径表类似，不过改为存储最短路径的总时间成本。</p>
</li>
<li><p>分层路径寻找<br>  利用两个不同粒度的导航图存储整个地图，例如对于中国地图，可以用粗粒度的导航图存储省之间的连接信息，细粒度的导航图存储城镇或道路的连接信息。当然如果两层不足以保证质量，也可以使用更多层。<br>  <img data-src="https://i.loli.net/2020/07/08/GI6qM1JOpsTX8gv.png" alt="分层路径寻找"></p>
</li>
</ul>
<h3 id="走出困境"><a href="#走出困境" class="headerlink" title="走出困境"></a>走出困境</h3><p>当一个环境中包含大量智能体时，智能体将很容易陷入困境，例如在狭窄的门附近拥堵。例如在一个狭窄的门口，某一智能体试图定位附近的一个路点作为目标。这时由于某些原因，智能体被挤出了门，而智能体仍然在试图向该路点直线移动。这时该智能体就会开始日墙。<br>解决方案是每当更新时，计算到当前路点的距离。如果这个值的变化超过了预期，就需要重新规划路径。</p>
<h2 id="目标驱动智能体行为"><a href="#目标驱动智能体行为" class="headerlink" title="目标驱动智能体行为"></a>目标驱动智能体行为</h2><p>游戏中智能体的游戏思路事实上可以分解为多个目标，而目标也可以分为更细。例如对于掠夺者游戏，角色为了赢得游戏，可以先去搜集武器；为了搜集武器，需要寻找武器的位置并获取武器；而如果在寻找武器的途中突然遇到了敌人，就需要评估双方实力并转而攻击敌人或者逃跑；攻击敌人的过程中需要选择合适的武器攻击敌人并不断走位；如果选择了攻击敌人并成功消灭敌人后，还需要继续刚才的寻找武器行为。  </p>
<ul>
<li>目标的实现类似于状态，不过分为更多层次。分解和试图达成目标的行为不断进行，直到整个层次已被遍历。目标具有类似状态模式中Enter，Execate，Exit的Activate，Process，Terminate方法。不同的是Activate可能需要每当激活该目标时被调用以进行初始化。  </li>
<li>层次目标的实现类似于组合模式。同时通过将子目标压入子目标容器的前面以添加子目标，按照LIFO的顺序进行处理。</li>
<li>目标之间的选择使用目标仲裁，通过整体目标Think实现，需要对当前的状态进行评估以计算不同目标的价值分数，比较得到合适的目标。</li>
<li>为实现自动恢复被中断的活动，例如击杀半路遇到的敌人后继续寻找武器这一功能，其整体实现原理需类似于下推自动机。如果出现击杀敌人后寻路起点变化导致寻路丢失，也会因寻路目标的Activate再次被调用而重新开始寻路。</li>
<li>游戏中可能需要一些特殊的障碍，例如打开开关才能开启的门。这些障碍应该存储在地图的信息中作为对AI透明的数据，需要花费的时间也应该体现在导航图的边成本中。为了使AI存储这些障碍，特殊的边需要额外存储对应的开关，当智能体试图通过该边时，通过备注的开关信息将开启开关这一新目标压入栈中</li>
</ul>
<h3 id="命令综述"><a href="#命令综述" class="headerlink" title="命令综述"></a>命令综述</h3><p>在掠夺者案例中，有如下一些组合命令举例</p>
<ul>
<li>Think<br>  也即游戏中的整体目标</li>
<li>GetItem<br>  控制角色寻找回血道具&#x2F;武器等，这与玩家的生命&#x2F;距离目标的距离等相关。如果需要让角色在离物品较近时更倾向于获取物品，可以使评分与距离的平方成反比。</li>
<li>MoveToPosition<br>  试图将角色移动到地图上的任意位置，这会请求一条路径。如果利用时间片方式进行规划，在路径被规划完成前，角色可以随机漫步。</li>
<li>AttackTarget<br>  当玩家认为自己能够战胜当前目标敌人时，便可以主动攻击敌人。这包含了复杂的逻辑，例如选择合适的武器，进行走位以躲避子弹并达到武器最佳攻击距离等等。角色攻击目标的评分可以取决于当前双方的生命值&#x2F;距离&#x2F;武器等因素</li>
<li>HuntTarget<br>  当AttackTarget行为的目标消失在视线中时，角色可能需要继续追击敌人。这需要再次评估且评分应当低于攻击视线中的同样敌人，毕竟追击敌人需要承担更多的未知风险。</li>
</ul>
<p>和如下基本命令举例</p>
<ul>
<li>Wander<br>  控制角色随机漫步</li>
<li>TraverseEdge<br>  控制角色沿着一条路径移动，这可能需要使用上一节提供的各种技巧。</li>
</ul>
<h3 id="其他优化策略"><a href="#其他优化策略" class="headerlink" title="其他优化策略"></a>其他优化策略</h3><ul>
<li>使AI可以在一定程度上预判其他角色（例如玩家）的行为。例如当玩家残血时，AI控制角色移动到较近的血包附近埋伏玩家。这可以通过对玩家的当前状态调用AI的目标评估函数得知角色的大致行为，这种预判的准确性取决于你设计的AI评估函数是否贴近玩家心理。</li>
<li>使游戏中的AI具有不同个性。对于每种目标的评估函数，可以增加一个因子，作为角色的个性。例如在一个RTS游戏中，AI可以有运营风格，速攻风格等等；在掠夺者游戏中，AI可以有武器选择偏好，射击精度等等。  </li>
<li>不同于FSM，目标仲裁事实上是一个数据驱动而非逻辑驱动的算法，所以只需改变数据就能改变AI角色的个性与行为，也可以将数据单独存放在脚本文件或一个表中使其便于调试。</li>
</ul>
]]></content>
      <categories>
        <category>《游戏人工智能编程案例精粹》</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>《重构-改善既有代码的设计》学习笔记 (一)</title>
    <url>/2020/05/11/%E3%80%8A%E9%87%8D%E6%9E%84%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>关于《重构-改善既有代码的设计》第一版的学习笔记。虽然是二十年前的老书了，但是由于我不想看js案例，所以还是选择了第一版进行阅读。本节主要是重构的简介与代码的bad smell介绍。</p>
<span id="more"></span>

<h2 id="重构，第一个案例"><a href="#重构，第一个案例" class="headerlink" title="重构，第一个案例"></a>重构，第一个案例</h2><p>重构即为不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。</p>
<p>本章节以一个影片出租店用程序作为案例示范了重构的过程。主要部分没有什么特别的，值得注意的有以下两处</p>
<ul>
<li>某处重构中不使用临时变量储存函数值而改用两次调用外部函数。代码看起来更可读不过似乎影响效率，之后大概会解释重构与效率的取舍吧。</li>
<li>更改代码结构加入状态模式。不同影片的价格计算方式不同，但是由于类型可修改，不能简单使用继承。于是采用状态模式。此处影片的类型为可修改的状态，获取影片价格为状态对应的行为，虽然我看着更像策略模式…</li>
</ul>
<blockquote>
<p>重构之前，首先检查自己是否有一套可靠的测试机制，这些测试必须有自我检验能力</p>
</blockquote>
<blockquote>
<p>重构技术就是以微小的步伐修改程序，如果你犯下错误，很容易便可发现它</p>
</blockquote>
<blockquote>
<p>如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便地达成目的，那就先重构那个程序，使特性的添加比较容易进行，然后再添加特性。</p>
</blockquote>
<h2 id="重构原则"><a href="#重构原则" class="headerlink" title="重构原则"></a>重构原则</h2><blockquote>
<p><strong>重构:</strong> 对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。 或是使用一系列重构手法，在不改变软件可观察行为的前提下调整其结构。  </p>
</blockquote>
<h3 id="为何重构"><a href="#为何重构" class="headerlink" title="为何重构"></a>为何重构</h3><ul>
<li>重构改进软件设计</li>
<li>重构使软件更容易理解</li>
<li>重构帮助找到bug</li>
<li>重构提高编程速度</li>
</ul>
<h3 id="何时重构"><a href="#何时重构" class="headerlink" title="何时重构"></a>何时重构</h3><blockquote>
<p>事不过三，三则重构 </p>
</blockquote>
<ul>
<li>添加功能时重构</li>
<li>修补错误时重构</li>
<li>复审代码时重构</li>
</ul>
<h3 id="重构的难题"><a href="#重构的难题" class="headerlink" title="重构的难题"></a>重构的难题</h3><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ol>
<li>大多数商用程序都与数据库高度耦合  </li>
<li>容易导致数据迁移</li>
</ol>
<ul>
<li>对于非对象数据库，可以通过加入分隔层隔离两个模型各自的变化。这会增加系统复杂度但是可以带来很大的灵活度。  </li>
<li>无需一开始就插入分隔层，可以等对象模型不稳定时再产生。</li>
</ul>
<h4 id="修改接口"><a href="#修改接口" class="headerlink" title="修改接口"></a>修改接口</h4><p>对于已发布接口，可能会出现比公开接口更严重的问题。<br>这时需要同时维护新旧两个接口，直到所有用户都有时间对这个变化做出反应。让旧接口调用新接口，而非复制函数实现。对于java，可以使用 deprecation (意为不建议使用) 标记旧接口。<br>另一方面，若无必要，不要发布接口。可能意味着需要改变代码所有权观念，让每个人都可以修改别人的代码，以适应接口的改动。</p>
<blockquote>
<p>不要过早发布接口，请修改你的代码所有权政策，使重构更顺畅。</p>
</blockquote>
<h4 id="难以通过重构手法完成的设计改动"><a href="#难以通过重构手法完成的设计改动" class="headerlink" title="难以通过重构手法完成的设计改动"></a>难以通过重构手法完成的设计改动</h4><p>很难将不考虑安全性需求时构造起来的系统重构为具备良好安全性系统</p>
<h4 id="何时不该重构"><a href="#何时不该重构" class="headerlink" title="何时不该重构"></a>何时不该重构</h4><ul>
<li>当代码实在太混乱，重构它还不如重新写一个来得简单。</li>
<li>当代码满是错误。</li>
<li>如果项目已近最后期限</li>
</ul>
<h3 id="重构与性能"><a href="#重构与性能" class="headerlink" title="重构与性能"></a>重构与性能</h3><p>重构可能使软件运行更慢，但它也使软件的优化更容易。除了对性能有要求的实时系统，其他任何情况下都应写出可调的软件，然后调整它以求获得足够速度。</p>
<h4 id="编写快速软件的方法"><a href="#编写快速软件的方法" class="headerlink" title="编写快速软件的方法"></a>编写快速软件的方法</h4><ul>
<li>时间预算法<br>从分解设计开始做好时间预算，适用于心律调节器等高度重视性能的系统</li>
<li>持续关注法<br>要求程序员做任何事时设法保持高性能</li>
<li>性能提升法<br>不关注性能直到性能优化阶段(通常在开发后期)</li>
</ul>
<h2 id="代码的坏味道"><a href="#代码的坏味道" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h2><h3 id="Duplicated-Code-重复代码"><a href="#Duplicated-Code-重复代码" class="headerlink" title="Duplicated Code (重复代码)"></a>Duplicated Code (重复代码)</h3><ul>
<li><p>同一个类的两个函数含有相同的表达式  </p>
<p>  采用 Extract Method 提炼出重复代码，然后让这两个地点都调用被提炼出来的那一段代码</p>
</li>
<li><p>同一个互为兄弟的子类内出现  </p>
<ul>
<li>如果含有相同表达式。对两个类使用 Extract Method ，再对被提炼出来的代码使用 Pull Up Method ,将它推入超类中。</li>
<li>如果两个代码只是相似，运用 Extract Method 将相似部分和差异部分割开，构成单独一个函数。然后可能可以运用 Form Template Method 获得模版方法设计模式。</li>
<li>如果以不同的算法做相同的事，选择较清晰的一个，用 Substitute Algorithm 将其他函数的算法替换掉</li>
</ul>
</li>
<li><p>两个毫不相关的类<br>  对其中一个使用 Extra Class，将重复代码提炼到一个独立类中。注意考虑原有类与新类的关系。</p>
</li>
</ul>
<h3 id="Long-Method-过长函数"><a href="#Long-Method-过长函数" class="headerlink" title="Long Method (过长函数)"></a>Long Method (过长函数)</h3><ul>
<li>每当需要使用注释说明时，便将需要说明的东西写进独立函数中，并以其用途命名。关键不在于函数长度，而在于函数 “What” 和 “How” 之间的距离。<ul>
<li>大多情况只需要 Extract Method。</li>
<li>如果有大量参数和临时变量。运用 Replace Temp with Query 来消除临时元素。Introduce Parameter Object 和 Preserve Whole Object 则可以简化参数列表  </li>
<li>如果仍有太多临时变量和参数，使用 Replace Method with Method Object</li>
</ul>
</li>
<li>注意条件表达式和循环。可以使用 Decompose Conditional 处理条件表达式。循环和其内代码则应提炼到独立函数中</li>
</ul>
<h3 id="Large-Class-过大的类"><a href="#Large-Class-过大的类" class="headerlink" title="Large Class (过大的类)"></a>Large Class (过大的类)</h3><ul>
<li>如果类中有太多实例变量，通常可以使用 Extract Class 或 Extract Subclass</li>
<li>如果类中有太多代码，还可以使用 Extract Interface 为客户端对于类的每一种使用方式提炼出一个接口</li>
<li>如果是一个GUI类，可能需要把数据和行为移到一个独立的领域对象去。可能需要各保留一些重复数据，并保持两边同步。可以使用 Duplicate Observed Data</li>
</ul>
<h3 id="Long-Parameter-List-过长参数列"><a href="#Long-Parameter-List-过长参数列" class="headerlink" title="Long Parameter List (过长参数列)"></a>Long Parameter List (过长参数列)</h3><ul>
<li>如果向已有的对象发出一条请求就可以取代一个参数，那么你应该激活重构手法 Replace Parameter with Method 。  </li>
<li>还可以用 Preserve Whole Object 将来自同一对象的一堆数据收集起来，并以该对象替换他们。  </li>
<li>如果某些数据缺乏合理的对象归属，可使用 Introduce Parameter Object为它们制造出一个参数对象。  </li>
<li>例外情况，如果明显不希望产生某种依赖关系，将数据单独拆分成参数也合情合理。</li>
</ul>
<h3 id="Divergent-Change-发散式变化"><a href="#Divergent-Change-发散式变化" class="headerlink" title="Divergent Change (发散式变化)"></a>Divergent Change (发散式变化)</h3><p>如果某个类经常因为不同的原因在不同的方向上变化，应该找出某种特定原因而造成的所有变化，然后运用 Extract Class 将它们提炼到另一个类中</p>
<h3 id="Shotgun-Surgery-霰弹式修改"><a href="#Shotgun-Surgery-霰弹式修改" class="headerlink" title="Shotgun Surgery (霰弹式修改)"></a>Shotgun Surgery (霰弹式修改)</h3><p>与上一条相反，如果每遇到一种变化，你都必须在许多不同类中作出小修改，应该使用 Move Method 和 Move Field 把需要修改的代码放进同一个类。通常可以运用 Inline Class，这可能会导致少量的上一条中的发散式变化，但可以轻易地被处理</p>
<h3 id="Feature-Envy-依恋情节"><a href="#Feature-Envy-依恋情节" class="headerlink" title="Feature Envy (依恋情节)"></a>Feature Envy (依恋情节)</h3><p>函数对某个类的兴趣高过自己所处的类。</p>
<ul>
<li>通常关注的焦点是某个其他的类中的某些数据。通常使用 Move Method 即可</li>
<li>有时函数会用到几个类的功能。这时可以判断哪个类拥有最多被此函数使用的数据，也可以先以 Extract Method 将这个函数分解并放在不同地点</li>
<li>也有几个复杂的设计模式破坏了这一条。例如Strategy策略模式和Visitor访问者模式和自委托(啥玩意)。这些模式用于对抗前面的发散式变化。</li>
</ul>
<h3 id="Data-Clumps-数据泥团"><a href="#Data-Clumps-数据泥团" class="headerlink" title="Data Clumps (数据泥团)"></a>Data Clumps (数据泥团)</h3><p>在很多地方看到相同的三四项数据，例如两个类中相同的字段或是许多函数签名中相同的参数。  </p>
<ul>
<li>首先找出数据以字段形式出现的地方，运用 Extract Class 将它们提炼到独立的对象中，然后运用 Introduce Prarameter Object 或 Preserve Whole Object 缩减参数列表。 </li>
<li>一个评判方法 删掉众多数据中的一项，如果有数据失去类意义，意味着需要产生新对象。</li>
</ul>
<h3 id="Primitive-Obsession-基本类型偏执"><a href="#Primitive-Obsession-基本类型偏执" class="headerlink" title="Primitive Obsession (基本类型偏执)"></a>Primitive Obsession (基本类型偏执)</h3><p>新手通常不愿意在小任务上运用小对象。</p>
<ul>
<li>可以运用 Repalce Data Value with Object 将原本单独存在的数据值替换为对象</li>
<li>如果想要替换的数据值是类型码而它不影响行为。可以用 Replace Type Code with Class 将它替换掉。</li>
<li>如果有与类型码相关的条件表达式。可以用Replace Type Code with Subclass 或 Replace Type Code with State&#x2F;Strategy 加以处理</li>
<li>如果有一组总被放在一起的字段，可运用 Extract Class </li>
<li>如果在参数列表中看到基本类型数据，可运用 Introduce Parameter Object</li>
<li>如果正在从数组中挑选数据，可运用 Replace Array with Object</li>
</ul>
<h3 id="Switch-Statements-switch-惊悚现身"><a href="#Switch-Statements-switch-惊悚现身" class="headerlink" title="Switch Statements ( switch 惊悚现身 )"></a>Switch Statements ( switch 惊悚现身 )</h3><ul>
<li>一般考虑使用多态替换它</li>
<li>如果只是在单一函数中有些选择事例，可以用Replace Parameter with Explicit Methods</li>
<li>如果选择条件之一是 null ，可以使用 Introduce Null Object</li>
</ul>
<h3 id="Parallel-Inheritance-Hierachies-平行继承体系"><a href="#Parallel-Inheritance-Hierachies-平行继承体系" class="headerlink" title="Parallel Inheritance Hierachies (平行继承体系)"></a>Parallel Inheritance Hierachies (平行继承体系)</h3><p>每当你为某个类新增一个子类时，如果你必须为另一个类也增加一个类。<br>一般让一个继承体系的实例引用另一个继承体系的实例。也可以使用 Move Methods 和 Move Field</p>
<h3 id="Lazy-Class-冗赘类"><a href="#Lazy-Class-冗赘类" class="headerlink" title="Lazy Class (冗赘类)"></a>Lazy Class (冗赘类)</h3><p>去除无用的类。</p>
<ul>
<li>如果某些子类没有做足够的工作，使用 Collapse Hierachy </li>
<li>对于几乎没用的组件，使用 Inline Class</li>
</ul>
<h3 id="Speculative-Generality-夸夸其谈未来性"><a href="#Speculative-Generality-夸夸其谈未来性" class="headerlink" title="Speculative Generality (夸夸其谈未来性)"></a>Speculative Generality (夸夸其谈未来性)</h3><p>过度设想未来以企图处理一些非必要的事情。例如函数或类的唯一用户是测试用例。</p>
<ul>
<li>无用的抽象类，请运用 Collapse Hierarchy</li>
<li>不必要的委托，运用 Inline Class</li>
<li>函数有无用参数，实施 Remove Parameter</li>
<li>函数名带有多余的抽象，实施 Rename Method</li>
</ul>
<h3 id="Temporary-Field-令人迷惑的暂时字段"><a href="#Temporary-Field-令人迷惑的暂时字段" class="headerlink" title="Temporary Field (令人迷惑的暂时字段)"></a>Temporary Field (令人迷惑的暂时字段)</h3><ul>
<li>有时会看到某个实例变量仅为某种特定情况而设。<br>一般可以使用 Extract class，也许可以使用 Introduce Null Object 在变量不合法的情况下创建一个空对象，从而避免条件式代码</li>
<li>如果类中有一个复杂算法，需要好几个变量，也有可能出现这种情况。<br>可以利用 Extract Class 提炼到独立类中，成为新的函数对象</li>
</ul>
<h3 id="Message-Chains-过度耦合的消息链"><a href="#Message-Chains-过度耦合的消息链" class="headerlink" title="Message Chains (过度耦合的消息链)"></a>Message Chains (过度耦合的消息链)</h3><p>对象之间相互请求的链过长。意味着客户代码将与查找过程中的导航紧密耦合。<br>可以使用 Hide Delegate 。或是先观察消息链的最终对象，用 Extract Method 提炼到独立函数中，再使用 Move Method 推入消息链。  </p>
<h3 id="Middle-Man-中间人"><a href="#Middle-Man-中间人" class="headerlink" title="Middle Man (中间人)"></a>Middle Man (中间人)</h3><p>过度使用委托。</p>
<ul>
<li>如果只有少数几个不干实事的函数，使用 InlineMethod 把它们放进调用端</li>
<li>如果还有其他行为，运用 Replace Delegation with Inheritance 变为实责对象的子类</li>
</ul>
<h3 id="Inappropriate-Intimacy-狎昵关系"><a href="#Inappropriate-Intimacy-狎昵关系" class="headerlink" title="Inappropriate Intimacy (狎昵关系)"></a>Inappropriate Intimacy (狎昵关系)</h3><p>两个类过多关注彼此的私有部分。</p>
<ul>
<li>可以采用 Move Method 和 Move Field 划清界限</li>
<li>可以运用 Extra Class 将共同点提炼到一个新的类</li>
<li>可以运用 Hide Delegate 传递这些信息</li>
<li>继承也会导致这一问题。可以使用 Replace Inheritance with Delegation 使其离开继承体系</li>
</ul>
<h3 id="Alternative-Classes-with-Different-Interfaces-异曲同工的类"><a href="#Alternative-Classes-with-Different-Interfaces-异曲同工的类" class="headerlink" title="Alternative Classes with Different Interfaces (异曲同工的类)"></a>Alternative Classes with Different Interfaces (异曲同工的类)</h3><p>两个类做同一件事却有不同的签名。</p>
<ul>
<li>可以运用 Rename Method 重命名。</li>
<li>还需要反复运用 Move Method 将某些行为移入类，直到两者的协议一致为止</li>
<li>如果移动方法过于重复累赘，可以运用 Extract Superclass</li>
</ul>
<h3 id="Incomplete-Library-Class-不完美的库类"><a href="#Incomplete-Library-Class-不完美的库类" class="headerlink" title="Incomplete Library Class (不完美的库类)"></a>Incomplete Library Class (不完美的库类)</h3><p>关于程序库的一些问题。  </p>
<ul>
<li>如果你只想修改库类的一两个函数，可以运用 Introduce Foreign Method </li>
<li>如果想要添加大量额外行为，运用 Introduce Local Extension</li>
</ul>
<h3 id="Data-Class-纯稚的数据类"><a href="#Data-Class-纯稚的数据类" class="headerlink" title="Data Class (纯稚的数据类)"></a>Data Class (纯稚的数据类)</h3><p>一些纯粹的数据类，需要考虑是否得到了恰当的封装。尝试将其他地方对该类的调用搬移过来。</p>
<h3 id="Refused-Bequest-被拒绝的馈赠"><a href="#Refused-Bequest-被拒绝的馈赠" class="headerlink" title="Refused Bequest (被拒绝的馈赠)"></a>Refused Bequest (被拒绝的馈赠)</h3><p>子类可能不需要继承超类所有的东西。<br>一般而言意味着继承体系设计错误。传统说法中，所有的超类都应该是抽象的<br>当然这一问题并不经常引起困惑和问题，大多数情况无需在意</p>
<h3 id="Comments-过多的注释"><a href="#Comments-过多的注释" class="headerlink" title="Comments (过多的注释)"></a>Comments (过多的注释)</h3><p>当感觉需要撰写注释时，先尝试重构，试着让所有注释变得多余</p>
<h2 id="构筑测试体系"><a href="#构筑测试体系" class="headerlink" title="构筑测试体系"></a>构筑测试体系</h2><blockquote>
<p>确保所有测试都完全自动化，让它们检查自己的测试结果  </p>
</blockquote>
<p>需要添加特性时，先写相应测试代码。作者的喜好是在实践测试时先通过在断言中填写错误期望值或通过修改代码让测试不通过，以验证测试代码能正常工作。</p>
<blockquote>
<p>每当你收到bug报告，请先写一个单元测试来暴露bug  </p>
</blockquote>
<p>本章的案例使用了20年前的JUnit版本，不适用于现今的测试体系，不多赘述。</p>
]]></content>
      <categories>
        <category>《重构-改善既有代码的设计》</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>《重构-改善既有代码的设计》学习笔记（二）</title>
    <url>/2020/05/13/%E3%80%8A%E9%87%8D%E6%9E%84%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>关于《重构-改善既有代码的设计》第一版的学习笔记。本节主要是书中的重构列表也即具体重构方法。因内容较多,仅简单记录名称、解释和一些值得注意的细节以供查阅。</p>
<span id="more"></span>

<h2 id="重构列表"><a href="#重构列表" class="headerlink" title="重构列表"></a>重构列表</h2><h3 id="重新组织函数"><a href="#重新组织函数" class="headerlink" title="重新组织函数"></a>重新组织函数</h3><h4 id="Extract-Method-提炼函数"><a href="#Extract-Method-提炼函数" class="headerlink" title="Extract Method (提炼函数)"></a>Extract Method (提炼函数)</h4><ul>
<li>你有一段代码可以被组织在一起并独立出来  </li>
<li>将这段代码放进一个独立函数中，并让函数名称解释该函数的用途</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void printOwing(double amount)</span><br><span class="line">&#123;</span><br><span class="line">    printBanner();</span><br><span class="line"></span><br><span class="line">    // print details</span><br><span class="line">    System.out.println(&quot;name:&quot; + _name);</span><br><span class="line">    System.out.println(&quot;amount&quot; + _amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void printOwing(double amount)</span><br><span class="line">&#123;</span><br><span class="line">    printBanner();</span><br><span class="line">    printDetails(amount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printDetails(double amount)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(&quot;name&quot; + _name);</span><br><span class="line">    System.out.println(&quot;amount&quot; + amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意目标代码中的局部变量。如果需要对局部变量进行再次赋值并使用，提炼出的函数可以使用参数以及返回值。</p>
<h4 id="Inline-Method-内联函数"><a href="#Inline-Method-内联函数" class="headerlink" title="Inline Method (内联函数)"></a>Inline Method (内联函数)</h4><ul>
<li>一个函数的本体和名称同样清楚易懂  </li>
<li>在函数调用点插入函数本体，然后移除该函数</li>
</ul>
<p>与上一条完全相反，这里是去除不必要的间接性。另一种情况是需要整理大量不甚合理的小函数时，先全部内联到一个大函数中，再重新进行提炼。  </p>
<h4 id="Inline-Temp-内联临时变量"><a href="#Inline-Temp-内联临时变量" class="headerlink" title="Inline Temp (内联临时变量)"></a>Inline Temp (内联临时变量)</h4><ul>
<li>你有一个临时变量，只被一个简单表达式赋值一次，而妨碍了其他重构手法</li>
<li>将所有对该变量的引用动作，替换为对它赋值的那个表达式自身</li>
</ul>
<p>多半作为下一条的一部分使用，通常不会有什么危害，但是如果妨碍了其他重构思路，就可以将其内联化。使用时可以通过将这个临时变量设置为final以检查其是否只被赋值一次。</p>
<h4 id="Replace-Temp-with-Query-以查询取代临时变量"><a href="#Replace-Temp-with-Query-以查询取代临时变量" class="headerlink" title="Replace Temp with Query (以查询取代临时变量)"></a>Replace Temp with Query (以查询取代临时变量)</h4><ul>
<li>你的程序以一个临时变量保存某一表达式的运算结果</li>
<li>将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可以被其他函数使用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double basePrice = _quantity * _itemPrice;</span><br><span class="line">    if (basePrice &gt; 1000)</span><br><span class="line">        return basePrice * 0.95;</span><br><span class="line">    else</span><br><span class="line">        return basePrice * 0.95</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (basePrice() &gt; 1000)</span><br><span class="line">    return basePrice() * 0.95;</span><br><span class="line">else</span><br><span class="line">    return basePrice() * 0.95</span><br><span class="line">...</span><br><span class="line">double basePrice()</span><br><span class="line">&#123;</span><br><span class="line">    return _quantity * _itemPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是让一个函数中的表达式计算可以被其他函数使用。通常是 Extra Method 前的步骤。运用此手法可能会产生性能问题，但是通常可以忽略不计，或是可以在性能优化阶段解决。</p>
<h4 id="Introduce-Explaining-Variable-引入解释性变量"><a href="#Introduce-Explaining-Variable-引入解释性变量" class="headerlink" title="Introduce Explaining Variable (引入解释性变量)"></a>Introduce Explaining Variable (引入解释性变量)</h4><ul>
<li>你有一个复杂的表达式</li>
<li>将该复杂表达式(或其中一部分)的结果放进一个临时变量，以此变量名称来解释表达式用途。</li>
</ul>
<p>也是和上一条相反。当表达式非常复杂难以阅读时使用。当然，也可以使用 Extract Method。何时使用二者可以根据具体工作量来判断。</p>
<h4 id="Split-Temporary-Variable-分解临时变量"><a href="#Split-Temporary-Variable-分解临时变量" class="headerlink" title="Split Temporary Variable (分解临时变量)"></a>Split Temporary Variable (分解临时变量)</h4><ul>
<li>你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。</li>
<li>针对每次赋值，创造一个独立，对应的临时变量</li>
</ul>
<p>除了循环变量和结果收集变量。临时变量大多不应被多次赋值。也即临时变量不应承担多个责任。</p>
<h4 id="Remove-Assignments-to-Parameters-移除对参数的赋值"><a href="#Remove-Assignments-to-Parameters-移除对参数的赋值" class="headerlink" title="Remove Assignments to Parameters (移除对参数的赋值)"></a>Remove Assignments to Parameters (移除对参数的赋值)</h4><ul>
<li>代码对一个参数进行赋值</li>
<li>以一个临时变量取代该参数的位置</li>
</ul>
<p>以下为一段java代码(采用按值传递)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void aMethod(Object foo)</span><br><span class="line">&#123;</span><br><span class="line">    foo.modifyInSomeWay;    //可</span><br><span class="line">    foo = anotherObject;    //不可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这导致混用按值传递和按引用传递，降低代码清晰度。</p>
<h4 id="Replace-Method-with-Method-Object-以函数对象取代函数"><a href="#Replace-Method-with-Method-Object-以函数对象取代函数" class="headerlink" title="Replace Method with Method Object (以函数对象取代函数)"></a>Replace Method with Method Object (以函数对象取代函数)</h4><ul>
<li>你有一个大型函数，其中对局部变量的引用使你无法采用 Extract Method</li>
<li>将这个函数放进一个单独对象中，如此一来局部对象就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。</li>
</ul>
<h4 id="Substitute-Algorithm-替换算法"><a href="#Substitute-Algorithm-替换算法" class="headerlink" title="Substitute Algorithm (替换算法)"></a>Substitute Algorithm (替换算法)</h4><ul>
<li>你想要将某个算法替换为另一个更清晰的算法</li>
<li>将函数本体替换为另一个算法</li>
</ul>
<h3 id="在对象之间搬移特性"><a href="#在对象之间搬移特性" class="headerlink" title="在对象之间搬移特性"></a>在对象之间搬移特性</h3><h4 id="Move-Method-搬移函数"><a href="#Move-Method-搬移函数" class="headerlink" title="Move Method (搬移函数)"></a>Move Method (搬移函数)</h4><ul>
<li>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流:调用后者，或被后者调用</li>
<li>在该函数最常引用的类中建立一个有类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移除。</li>
</ul>
<h4 id="Move-Field-搬移字段"><a href="#Move-Field-搬移字段" class="headerlink" title="Move Field (搬移字段)"></a>Move Field (搬移字段)</h4><ul>
<li>你的程序中，某个字段被其所驻类之外的另一个类更多地用到</li>
<li>在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段</li>
</ul>
<h4 id="Extract-Class-提炼类"><a href="#Extract-Class-提炼类" class="headerlink" title="Extract Class (提炼类)"></a>Extract Class (提炼类)</h4><ul>
<li>某个类做了应该由两个类做的事</li>
<li>建立一个新类，将相关的字段和函数从旧类搬移到新类</li>
</ul>
<p>信号之一是类的子类化方式出现问题，如果子类化只影响了类的部分特性或类的不同特性需要以不同方式来子类化，这意味着需要分解原来的类。</p>
<h4 id="Inline-Class-将类内联化"><a href="#Inline-Class-将类内联化" class="headerlink" title="Inline Class (将类内联化)"></a>Inline Class (将类内联化)</h4><ul>
<li>某个类没有做太多事情</li>
<li>将这个类的所有特性搬移到另一个类中，然后移除原类</li>
</ul>
<p><del>看起来我需要被内联</del><br>这与上一条相反，当类不再有单独存在的理由时，应当将该类移入它的最频繁用户中。</p>
<h4 id="Hide-Delegate-隐藏“委托关系”"><a href="#Hide-Delegate-隐藏“委托关系”" class="headerlink" title="Hide Delegate (隐藏“委托关系”)"></a>Hide Delegate (隐藏“委托关系”)</h4><ul>
<li>客户通过一个委托类来调用另一个对象</li>
<li>在服务类上建立客户所需的所有函数，用以隐藏委托关系</li>
</ul>
<p>可以在服务器对象上放置一个简单的委托函数，将委托关系隐藏起来，从而去除一些依赖关系。这样即使发生委托关系上的方法，变化也将被限制在服务对象中，不会波及客户。</p>
<h4 id="Remove-Middle-Man-中间人"><a href="#Remove-Middle-Man-中间人" class="headerlink" title="Remove Middle Man (中间人)"></a>Remove Middle Man (中间人)</h4><ul>
<li>某个类做了过多的简单委托动作</li>
<li>让客户直接调用受托类</li>
</ul>
<p>与上一条相反，随着受托类的特性和功能越来越多，服务类会完全变成“中间人”，此时你就应该让客户直接调用受托类。使用这一条和上一条可以保证隐藏的程度是合适。</p>
<h4 id="Introduce-Foreign-Method-引入外加函数"><a href="#Introduce-Foreign-Method-引入外加函数" class="headerlink" title="Introduce Foreign Method (引入外加函数)"></a>Introduce Foreign Method (引入外加函数)</h4><ul>
<li>你需要为提供服务的类增加一个函数，但你无法修改这个类</li>
<li>在客户类中建立一个函数，并以第一参数形式传入一个服务类实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date newStart = new Date(previousEnd.getYear(),previousEnd.getMonth(),previousEnd.getDate() + 1);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date newStart = nextDay(previousEnd)</span><br></pre></td></tr></table></figure>

<p>正在使用一个类时，如果你需要一项服务而类无法供应，此时如果你能修改源码，可以自行添加一个新函数，如果不能，就要在客户端编码，补足所需的函数。明确信号是这个函数本应在服务类中实现，如果有可能，这些函数仍然应该放回到服务类。</p>
<h4 id="Introduce-Local-Extension-引入本地扩展"><a href="#Introduce-Local-Extension-引入本地扩展" class="headerlink" title="Introduce Local Extension (引入本地扩展)"></a>Introduce Local Extension (引入本地扩展)</h4><ul>
<li>你需要为服务类提供一些额外函数，但你无法修改这个类</li>
<li>建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。</li>
</ul>
<p>和上一条的情况类似，如果你需要少数函数，你可以使用上一条的方法，而如果你需要加入多个函数，就可以使用本地扩展。例如子类化和包装。作者通常采取子类。</p>
<h3 id="重新组织数据"><a href="#重新组织数据" class="headerlink" title="重新组织数据"></a>重新组织数据</h3><h4 id="Self-Encapsulate-Field-自封装字段"><a href="#Self-Encapsulate-Field-自封装字段" class="headerlink" title="Self Encapsulate Field (自封装字段)"></a>Self Encapsulate Field (自封装字段)</h4><ul>
<li>你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙</li>
<li>为这个字段建立取值&#x2F;设值函数，并且只以这些函数来访问字段</li>
</ul>
<p>如果一个类中有private字段，是否可以自由访问，还是应该使用访问函数间接访问，有两个说法。<br>间接访问变量的函数的好处是，子类可以通过覆写一个函数而改变获取数据的途径；它还支持更灵活的数据管理方式，例如延迟初始化。<br>直接访问变量的好处则是，代码比较容易阅读。<br>如果你想要访问超类中的一个字段，却又想在子类中将对这个变量的访问改为一个计算后的值，就应该使用这一方法。</p>
<h4 id="Replace-Data-Value-with-Object-以对象取代数据值"><a href="#Replace-Data-Value-with-Object-以对象取代数据值" class="headerlink" title="Replace Data Value with Object (以对象取代数据值)"></a>Replace Data Value with Object (以对象取代数据值)</h4><ul>
<li>你有一个数据项，需要与其他数据和行为一起使用才有意义</li>
<li>将数据项变成对象</li>
</ul>
<p>开发初期，对于电话号码一类的数据可能会出现，早期使用字符串表示，但后来发现需要抽取区号等行为。如果这样的数据项只有一两个，你可以把相关函数放进数据项所属的对象里；但是 Duplicate Code 和 Feature Envy bad smell就可能会出现，这时就需要把数据值变成对象。</p>
<h4 id="Change-Value-to-Reference-将值对象改为引用对象"><a href="#Change-Value-to-Reference-将值对象改为引用对象" class="headerlink" title="Change Value to Reference (将值对象改为引用对象)"></a>Change Value to Reference (将值对象改为引用对象)</h4><ul>
<li>你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象</li>
</ul>
<h4 id="Change-Reference-to-Value-将引用对象改为值对象"><a href="#Change-Reference-to-Value-将引用对象改为值对象" class="headerlink" title="Change Reference to Value (将引用对象改为值对象)"></a>Change Reference to Value (将引用对象改为值对象)</h4><ul>
<li>你有一个引用对象，很小且不可变，而且不易管理</li>
</ul>
<p>和上一条相反。如果引用对象开始难以使用，就可能需要改为值对象。<br>值对象的重要特性是不可变(immutable)的。例如如果用Money类表示钱的概念，那Money类通常是一个不可变的值对象，这不意味着你的薪资不能改变，而是说改变薪资需要使用新的Money类对象代替而非修改现有的Money类。  </p>
<h4 id="Replace-Array-with-Object-以对象取代数组"><a href="#Replace-Array-with-Object-以对象取代数组" class="headerlink" title="Replace Array with Object (以对象取代数组)"></a>Replace Array with Object (以对象取代数组)</h4><ul>
<li>你有一个数组，其中的元素各自代表不同的东西</li>
<li>以对象替换数组。对于数组中的每个元素，以一个字段来表示</li>
</ul>
<h4 id="Duplicate-Observed-Data-复制-“被监视数据”"><a href="#Duplicate-Observed-Data-复制-“被监视数据”" class="headerlink" title="Duplicate Observed Data (复制 “被监视数据”)"></a>Duplicate Observed Data (复制 “被监视数据”)</h4><ul>
<li>你有一些领域置身于GUI控件中，而领域函数需要访问这些数据</li>
<li>将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据</li>
</ul>
<h4 id="Change-Unidirectional-Association-to-Bidirectional-将单向关联改为双向关联"><a href="#Change-Unidirectional-Association-to-Bidirectional-将单向关联改为双向关联" class="headerlink" title="Change Unidirectional Association to Bidirectional (将单向关联改为双向关联)"></a>Change Unidirectional Association to Bidirectional (将单向关联改为双向关联)</h4><ul>
<li>两个类都需要使用对方特性，但其间只有一条单向连接</li>
<li>添加一个反向指针，并使修改函数能够同时更新两条连接</li>
</ul>
<h4 id="Change-Bidirectional-Association-to-Unidirectional-将双向关联改为单向关联"><a href="#Change-Bidirectional-Association-to-Unidirectional-将双向关联改为单向关联" class="headerlink" title="Change Bidirectional Association to Unidirectional (将双向关联改为单向关联)"></a>Change Bidirectional Association to Unidirectional (将双向关联改为单向关联)</h4><ul>
<li>两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性</li>
<li>去除不必要的关联</li>
</ul>
<h4 id="Replace-Magic-Number-with-Symbolic-Constant-以字面常量取代魔法数"><a href="#Replace-Magic-Number-with-Symbolic-Constant-以字面常量取代魔法数" class="headerlink" title="Replace Magic Number with Symbolic Constant (以字面常量取代魔法数)"></a>Replace Magic Number with Symbolic Constant (以字面常量取代魔法数)</h4><ul>
<li>你有一个字面数值，带有特别含义</li>
<li>创造一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量</li>
</ul>
<h4 id="Encapsulated-Field-封装字段"><a href="#Encapsulated-Field-封装字段" class="headerlink" title="Encapsulated Field (封装字段)"></a>Encapsulated Field (封装字段)</h4><ul>
<li>你的类中存在一个public字段</li>
<li>将它声明为private，并提供相应的访问函数</li>
</ul>
<h4 id="Encapsulate-Collection-封装集合"><a href="#Encapsulate-Collection-封装集合" class="headerlink" title="Encapsulate Collection (封装集合)"></a>Encapsulate Collection (封装集合)</h4><ul>
<li>有个函数返回一个集合</li>
<li>让这个函数返回该集合的一个只读副本，并在这个类中提供添加&#x2F;移除集合元素的函数</li>
</ul>
<h4 id="Replace-Record-with-Data-Class-以数据类取代记录"><a href="#Replace-Record-with-Data-Class-以数据类取代记录" class="headerlink" title="Replace Record with Data Class (以数据类取代记录)"></a>Replace Record with Data Class (以数据类取代记录)</h4><ul>
<li>你需要面对传统编程环境中的记录结构</li>
<li>为该记录创建一个“哑”数据对象</li>
</ul>
<p>创建一个接口类以处理外来的记录型结构(所以记录式结构是什么)</p>
<h4 id="Replace-Type-Code-with-Class-以类取代类型码"><a href="#Replace-Type-Code-with-Class-以类取代类型码" class="headerlink" title="Replace Type Code with Class (以类取代类型码)"></a>Replace Type Code with Class (以类取代类型码)</h4><ul>
<li>类之中有一个数值类型码，但它并不影响类的行为</li>
<li>以一个新的类替换该数值类型码</li>
</ul>
<h4 id="Replace-Type-Code-with-Subclasses-以子类取代类型码）"><a href="#Replace-Type-Code-with-Subclasses-以子类取代类型码）" class="headerlink" title="Replace Type Code with Subclasses (以子类取代类型码）"></a>Replace Type Code with Subclasses (以子类取代类型码）</h4><ul>
<li>你有一个不可变的类型码，它会影响类的行为</li>
<li>以子类取代这个类型码</li>
</ul>
<h4 id="Replace-Type-Code-with-State-Strategy-以-State-Strategy-取代类型码"><a href="#Replace-Type-Code-with-State-Strategy-以-State-Strategy-取代类型码" class="headerlink" title="Replace Type Code with State&#x2F;Strategy (以 State&#x2F;Strategy 取代类型码)"></a>Replace Type Code with State&#x2F;Strategy (以 State&#x2F;Strategy 取代类型码)</h4><ul>
<li>你有一个类型码，它会影响类的行为，但你无法通过继承手法消除它</li>
<li>以状态对象取代类型码</li>
</ul>
<p>如果类型码的值在对象生命周期中发生变化或其他原因使得宿主类不能被继承，可以使用本重构</p>
<h4 id="Replace-Subclass-with-Fields-以字段取代子类"><a href="#Replace-Subclass-with-Fields-以字段取代子类" class="headerlink" title="Replace Subclass with Fields (以字段取代子类)"></a>Replace Subclass with Fields (以字段取代子类)</h4><ul>
<li>你的各个子类的唯一差别只在“返回常量数据”的函数上</li>
<li>修改这个函数，使他们返回超类中的某个(新增)字段，然后销毁子类</li>
</ul>
<h3 id="简化条件表达式"><a href="#简化条件表达式" class="headerlink" title="简化条件表达式"></a>简化条件表达式</h3><h4 id="Decompose-Conditional-分解条件表达式"><a href="#Decompose-Conditional-分解条件表达式" class="headerlink" title="Decompose Conditional (分解条件表达式)"></a>Decompose Conditional (分解条件表达式)</h4><ul>
<li>你有一个复杂的条件 (if - then - else)</li>
<li>从 if，then，else 三个段落中分别提炼出独立函数</li>
</ul>
<h4 id="Consolidate-Conditional-Expression-合并条件表达式"><a href="#Consolidate-Conditional-Expression-合并条件表达式" class="headerlink" title="Consolidate Conditional Expression (合并条件表达式)"></a>Consolidate Conditional Expression (合并条件表达式)</h4><ul>
<li>你有一系列条件测试，都得到相同结果</li>
<li>将这些测试合并为一个条件表达式，并将这个条件式提炼成为一个独立函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double disabilityAmount()</span><br><span class="line">&#123;</span><br><span class="line">    if (_seniority &lt; 2) return 0;</span><br><span class="line">    if (_monthsDisabled &lt; 12) return 0;</span><br><span class="line">    if (_isPartTime) return 0;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double disabilityAmount()</span><br><span class="line">&#123;</span><br><span class="line">    if (isNotEligableForDisability()) return 0;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Consolidate-Duplicate-Conditional-Fragments-合并重复的条件片段"><a href="#Consolidate-Duplicate-Conditional-Fragments-合并重复的条件片段" class="headerlink" title="Consolidate Duplicate Conditional Fragments (合并重复的条件片段)"></a>Consolidate Duplicate Conditional Fragments (合并重复的条件片段)</h4><ul>
<li>在条件表达式的每个分支上有着相同的一段代码</li>
<li>将这段重复代码搬移到条件表达式之外</li>
</ul>
<h4 id="Remove-Control-Flag-移除控制标记"><a href="#Remove-Control-Flag-移除控制标记" class="headerlink" title="Remove Control Flag (移除控制标记)"></a>Remove Control Flag (移除控制标记)</h4><ul>
<li>在一系列布尔表达式中，某个变量带有”控制标记”(control flag)的作用</li>
<li>以 break 语句或 return 语句取代控制标记<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void checkSecurity(String people)</span><br><span class="line">&#123;</span><br><span class="line">    boolean found = false;</span><br><span class="line">    for (int i = 0; i &lt; people.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!found)</span><br><span class="line">        &#123;</span><br><span class="line">            if (people(i).equals(&quot;Don&quot;))</span><br><span class="line">            &#123;</span><br><span class="line">                sendAlert();</span><br><span class="line">                found = true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (people(i).equals(&quot;John&quot;))</span><br><span class="line">            &#123;</span><br><span class="line">                sendAlert();</span><br><span class="line">                found = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void checkSecurity(String[] people)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; people.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (people(i).equals(&quot;Don&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            sendAlert();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (people(i).equals(&quot;John&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            sendAlert();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两段书中示例的代码在同时满足两个条件时的输出是不一致的，不过对于示例中检测两个嫌疑人名字的情形应该不会出现这种情况。<br>如果这里的found同时用于输出结果，可以使用 return 重构</p>
<h4 id="Replace-Nested-Conditional-with-Guard-Clauses-以卫语句取代嵌套表达式"><a href="#Replace-Nested-Conditional-with-Guard-Clauses-以卫语句取代嵌套表达式" class="headerlink" title="Replace Nested Conditional with Guard Clauses (以卫语句取代嵌套表达式)"></a>Replace Nested Conditional with Guard Clauses (以卫语句取代嵌套表达式)</h4><ul>
<li>函数中的条件逻辑使人难以看清正常的执行路径</li>
<li>使用卫语句表现所有特殊情况<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double getPayAmount()</span><br><span class="line">&#123;</span><br><span class="line">    double result;</span><br><span class="line">    if (_isDead)</span><br><span class="line">    &#123;</span><br><span class="line">        result = deadAmount();</span><br><span class="line">    &#125;</span><br><span class="line">    else </span><br><span class="line">    &#123;</span><br><span class="line">        if (_isSeparted) </span><br><span class="line">        &#123;</span><br><span class="line">            result = separatedAmount();</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (_isRetired) result = retiredAmount();</span><br><span class="line">            else result = normalPayAmount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double getPayAmount()</span><br><span class="line">&#123;</span><br><span class="line">    if (_isDead) return deadAmount();</span><br><span class="line">    if (_isSeparated) return separatedAmount();</span><br><span class="line">    if (_isRetired) return retiredAmount();</span><br><span class="line">    return normalPayAmount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>条件表达式通常有两种表现形式，一种是所有分支都是正常行为，另一种是只有一种是正常行为，其他都是特殊情况。<br>对于第一种就应该使用if-else语句，而对于第二种就应当使用卫语句。卫语句通常从函数中返回或抛异常。</p>
<h4 id="Replace-Conditional-with-Polymorphism-以多态取代条件表达式"><a href="#Replace-Conditional-with-Polymorphism-以多态取代条件表达式" class="headerlink" title="Replace Conditional with Polymorphism (以多态取代条件表达式)"></a>Replace Conditional with Polymorphism (以多态取代条件表达式)</h4><ul>
<li>你手上有个条件表达式，它根据对象类型的不同而选择不同的行为</li>
<li>将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数</li>
</ul>
<h4 id="Introduce-Null-Object-引入Null对象"><a href="#Introduce-Null-Object-引入Null对象" class="headerlink" title="Introduce Null Object (引入Null对象)"></a>Introduce Null Object (引入Null对象)</h4><ul>
<li>你需要再三检查某对象是否为null</li>
<li>将null值替换为null对象</li>
</ul>
<p>也即引入 Null Object 设计模式。<br>例如对于 Customer 对象和持有的 getPlan 方法，可以建立空对象类 Null Customer 继承 Customer 类，并用空对象对应行为替换 Null Customer 类的 getPlan 方法。<br>实际使用时，注意在源类和子类中加入 isNull() 函数,前者返回 false ，后者的 isNull() 返回true。也可以建立 nullable 接口将 isNull() 放在其中。之后所有将源对象与 null 比较的地方就可以调用 isNull() 函数。</p>
<h4 id="Introduce-Assertion-引入断言"><a href="#Introduce-Assertion-引入断言" class="headerlink" title="Introduce Assertion (引入断言)"></a>Introduce Assertion (引入断言)</h4><ul>
<li>某一段代码需要对程序状态做出某种假设</li>
<li>以断言明确表现这种假设<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double getExpenseLimit()</span><br><span class="line">&#123;</span><br><span class="line">    // should have either expense limit or a primary project</span><br><span class="line">    return (_expenseLimit != NULL_EXPENSE) ?</span><br><span class="line">        _expenseLimit:</span><br><span class="line">        _primaryProject.getMemberExpenseLimit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double getExpenseLimit()</span><br><span class="line">&#123;</span><br><span class="line">    Assert.isTure(_expenseLimit != NULL_EXPENSE || _primaryProject != null)</span><br><span class="line">    return (_expenseLimit != NULL_EXPENSE) ?</span><br><span class="line">        _expenseLimit:</span><br><span class="line">        _primaryProject.getMemberExpenseLimit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="简化函数调用"><a href="#简化函数调用" class="headerlink" title="简化函数调用"></a>简化函数调用</h3><h4 id="Rename-Method-函数改名"><a href="#Rename-Method-函数改名" class="headerlink" title="Rename Method (函数改名)"></a>Rename Method (函数改名)</h4><ul>
<li>函数的名称未能揭示函数的用途</li>
<li>修改函数名称</li>
</ul>
<p>作者提倡的好方法是先考虑给这个函数写上一句怎样的注释，再想办法将注释变成函数名称。</p>
<h4 id="Add-Parameter-添加参数"><a href="#Add-Parameter-添加参数" class="headerlink" title="Add Parameter (添加参数)"></a>Add Parameter (添加参数)</h4><ul>
<li>某个函数需要从调用端得到更多信息</li>
<li>为此函数添加一个对象参数，让该对象带进函数所需信息</li>
</ul>
<h4 id="Remove-Parameter-移除参数"><a href="#Remove-Parameter-移除参数" class="headerlink" title="Remove Parameter (移除参数)"></a>Remove Parameter (移除参数)</h4><ul>
<li>函数本体不再需要某个参数</li>
<li>将该参数去除</li>
</ul>
<h4 id="Separate-Query-from-Modifier-将查询函数和修改函数分离"><a href="#Separate-Query-from-Modifier-将查询函数和修改函数分离" class="headerlink" title="Separate Query from Modifier (将查询函数和修改函数分离)"></a>Separate Query from Modifier (将查询函数和修改函数分离)</h4><ul>
<li>某个函数既返回对象状态值，又修改对象状态</li>
<li>建立两个不同的函数，其中一个负责查询，另一个负责修改</li>
</ul>
<p>也即分离 getter setter</p>
<h4 id="Parameterize-Method-令函数携带参数"><a href="#Parameterize-Method-令函数携带参数" class="headerlink" title="Parameterize Method (令函数携带参数)"></a>Parameterize Method (令函数携带参数)</h4><ul>
<li>若干函数做了类似的工作，但在函数本体中却包括了不同的值</li>
<li>建立单一函数，以参数表达那些不同的值</li>
</ul>
<h4 id="Replace-Parameter-with-Explicit-Methods-以明确函数取代参数"><a href="#Replace-Parameter-with-Explicit-Methods-以明确函数取代参数" class="headerlink" title="Replace Parameter with Explicit Methods (以明确函数取代参数)"></a>Replace Parameter with Explicit Methods (以明确函数取代参数)</h4><ul>
<li>你有一个函数，其中完全取决于参数值而采取不同行为</li>
<li>针对该参数的每一个可能值，建立一个独立函数</li>
</ul>
<h4 id="Preserve-Whole-Object-保持对象完整"><a href="#Preserve-Whole-Object-保持对象完整" class="headerlink" title="Preserve Whole Object (保持对象完整)"></a>Preserve Whole Object (保持对象完整)</h4><ul>
<li>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数</li>
<li>改为传递整个对象</li>
</ul>
<h4 id="Replace-Parameter-with-Methods-以函数取代参数"><a href="#Replace-Parameter-with-Methods-以函数取代参数" class="headerlink" title="Replace Parameter with Methods (以函数取代参数)"></a>Replace Parameter with Methods (以函数取代参数)</h4><ul>
<li>对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能够调用前一个函数</li>
<li>让参数接受者去除该项参数，并直接调用前一个函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int basePrice = _quantity * _itemPrice;</span><br><span class="line">discountLevel = getDiscountLevel();</span><br><span class="line">double finalPrice = discountedPrice(basePrice,discountLevel);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int basePrice = _quantity * _itemPrice;</span><br><span class="line">double finalPrice = discountedPrice(basePrice);</span><br></pre></td></tr></table></figure>

<h4 id="Introduce-Parameter-Object-引入参数对象"><a href="#Introduce-Parameter-Object-引入参数对象" class="headerlink" title="Introduce Parameter Object (引入参数对象)"></a>Introduce Parameter Object (引入参数对象)</h4><ul>
<li>某些参数总是很自然地同时出现</li>
<li>以一个对象取代这些参数</li>
</ul>
<h4 id="Remove-Setting-Method-移除设值函数"><a href="#Remove-Setting-Method-移除设值函数" class="headerlink" title="Remove Setting Method (移除设值函数)"></a>Remove Setting Method (移除设值函数)</h4><ul>
<li>类中的某个字段应该在对象创建时被设值，然后就不再改变</li>
<li>去掉该字段的所有设值函数</li>
</ul>
<h4 id="Hide-Method-隐藏函数"><a href="#Hide-Method-隐藏函数" class="headerlink" title="Hide Method (隐藏函数)"></a>Hide Method (隐藏函数)</h4><ul>
<li>有一个函数，从来没有被其他任何类用到</li>
<li>将这个函数修改为 private</li>
</ul>
<h4 id="Replace-Constructor-with-Factory-Method-以工厂函数取代构造函数"><a href="#Replace-Constructor-with-Factory-Method-以工厂函数取代构造函数" class="headerlink" title="Replace Constructor with Factory Method (以工厂函数取代构造函数)"></a>Replace Constructor with Factory Method (以工厂函数取代构造函数)</h4><ul>
<li>你希望在创建对象时不仅仅是做简单的建构动作</li>
<li>将构造函数替换为工厂函数</li>
</ul>
<p>最显而易见的用途是在派生子类的过程中以工厂函数取代类型码，或者构造函数的功能不能满足你的需要，也可以用工厂函数替代它。</p>
<h4 id="Encapsulate-Downcast-封装向下转型"><a href="#Encapsulate-Downcast-封装向下转型" class="headerlink" title="Encapsulate Downcast (封装向下转型)"></a>Encapsulate Downcast (封装向下转型)</h4><ul>
<li>某个函数返回的对象，需要由函数调用者执行向下转型(downcast)</li>
<li>将向下转型动作移到函数上</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object lastReading()</span><br><span class="line">&#123;</span><br><span class="line">    return readings.lastElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object lastReading()</span><br><span class="line">&#123;</span><br><span class="line">    return (Reading) reading.lastElment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Replace-Error-Code-with-Exception-以异常取代错误码"><a href="#Replace-Error-Code-with-Exception-以异常取代错误码" class="headerlink" title="Replace Error Code with Exception (以异常取代错误码)"></a>Replace Error Code with Exception (以异常取代错误码)</h4><ul>
<li>某个函数返回一个特定的代码，用以表示某种错误情况</li>
<li>改用异常</li>
</ul>
<h4 id="Replace-Exception-with-Test-以测试取代异常"><a href="#Replace-Exception-with-Test-以测试取代异常" class="headerlink" title="Replace Exception with Test (以测试取代异常)"></a>Replace Exception with Test (以测试取代异常)</h4><ul>
<li>面对一个调用者可以预先检查的条件，你抛出了一个异常</li>
<li>修改调用者，使它在调用函数之前先做检查</li>
</ul>
<h3 id="处理概括关系"><a href="#处理概括关系" class="headerlink" title="处理概括关系"></a>处理概括关系</h3><h4 id="Pull-Up-Field-字段上移"><a href="#Pull-Up-Field-字段上移" class="headerlink" title="Pull Up Field (字段上移)"></a>Pull Up Field (字段上移)</h4><ul>
<li>两个子类拥有相同的字段</li>
<li>将该字段移至超类</li>
</ul>
<h4 id="Pull-Up-Method-函数上移"><a href="#Pull-Up-Method-函数上移" class="headerlink" title="Pull Up Method (函数上移)"></a>Pull Up Method (函数上移)</h4><ul>
<li>有些函数，在各个子类中产生完全相同的结果</li>
<li>将该函数移至超类</li>
</ul>
<h4 id="Pull-Up-Constructor-Body-构造函数本体上移"><a href="#Pull-Up-Constructor-Body-构造函数本体上移" class="headerlink" title="Pull Up Constructor Body (构造函数本体上移)"></a>Pull Up Constructor Body (构造函数本体上移)</h4><ul>
<li>你在各个子类中拥有一些构造函数，它们的本体几乎完全一致</li>
<li>在超类中新建一个构造函数，并在子类构造函数中调用它</li>
</ul>
<h4 id="Push-Down-Method-函数下移"><a href="#Push-Down-Method-函数下移" class="headerlink" title="Push Down Method (函数下移)"></a>Push Down Method (函数下移)</h4><ul>
<li>超类中的某个函数只与部分(而非全部)子类有关</li>
<li>将这个函数移到相关的那些子类去</li>
</ul>
<h4 id="Push-Down-Field-字段下移"><a href="#Push-Down-Field-字段下移" class="headerlink" title="Push Down Field (字段下移)"></a>Push Down Field (字段下移)</h4><ul>
<li>超类中的某个字段只被部分(而非全部)子类用到</li>
<li>将这个字段移到需要它的那些子类去</li>
</ul>
<h4 id="Extract-Superclass-提炼超类"><a href="#Extract-Superclass-提炼超类" class="headerlink" title="Extract Superclass (提炼超类)"></a>Extract Superclass (提炼超类)</h4><ul>
<li>两个类有相似特性</li>
<li>为这两个类建立一个超类，将相同特性移至超类</li>
</ul>
<h4 id="Extract-Interface-提炼接口"><a href="#Extract-Interface-提炼接口" class="headerlink" title="Extract Interface (提炼接口)"></a>Extract Interface (提炼接口)</h4><ul>
<li>若干客户使用类接口中的同一子类，或者两个类的接口有部分相同</li>
<li>将相同的子集提炼到一个独立接口中</li>
</ul>
<h4 id="Collapse-Hierarchy-折叠继承体系"><a href="#Collapse-Hierarchy-折叠继承体系" class="headerlink" title="Collapse Hierarchy (折叠继承体系)"></a>Collapse Hierarchy (折叠继承体系)</h4><ul>
<li>超类和子类之间无太大区别</li>
<li>将它们合为一体</li>
</ul>
<h4 id="Form-TemPlate-Method-塑造模版函数"><a href="#Form-TemPlate-Method-塑造模版函数" class="headerlink" title="Form TemPlate Method (塑造模版函数)"></a>Form TemPlate Method (塑造模版函数)</h4><ul>
<li>你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同</li>
<li>将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类</li>
</ul>
<h4 id="Replace-Inheritance-with-Delegation-以委托取代继承"><a href="#Replace-Inheritance-with-Delegation-以委托取代继承" class="headerlink" title="Replace Inheritance with Delegation (以委托取代继承)"></a>Replace Inheritance with Delegation (以委托取代继承)</h4><ul>
<li>某个子类只使用超类接口中的一部分，或是根本不需要继承而来的错误</li>
<li>在子类中新建一个字段用以保存超类;调查子类函数，令它改而委托超类;然后去掉两者之间的继承关系</li>
</ul>
<h4 id="Replace-Delegation-with-Inheritance-以继承取代委托"><a href="#Replace-Delegation-with-Inheritance-以继承取代委托" class="headerlink" title="Replace Delegation with Inheritance (以继承取代委托)"></a>Replace Delegation with Inheritance (以继承取代委托)</h4><ul>
<li>你在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数</li>
<li>让委托类继承受托类</li>
</ul>
<h3 id="大型重构"><a href="#大型重构" class="headerlink" title="大型重构"></a>大型重构</h3><p><del>理论上这一章配个图比较合适，不过我的书有水印不想截图，又懒得画类图，所以没有图</del></p>
<h4 id="Tease-Apart-Inheritance-梳理并分解继承体系"><a href="#Tease-Apart-Inheritance-梳理并分解继承体系" class="headerlink" title="Tease Apart Inheritance (梳理并分解继承体系)"></a>Tease Apart Inheritance (梳理并分解继承体系)</h4><ul>
<li>某个继承体系同时承担两项责任</li>
<li>建立两个继承体系，并通过委托让其中一个可以调用另一个</li>
</ul>
<h4 id="Convert-Procedural-Design-to-Objects-将过程化设计转化为对象设计"><a href="#Convert-Procedural-Design-to-Objects-将过程化设计转化为对象设计" class="headerlink" title="Convert Procedural Design to Objects (将过程化设计转化为对象设计)"></a>Convert Procedural Design to Objects (将过程化设计转化为对象设计)</h4><ul>
<li>你手上有一些传统过程化风格的代码</li>
<li>将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象之中</li>
</ul>
<h4 id="Separate-Domain-from-Presentation-将领域和表述-显示分离"><a href="#Separate-Domain-from-Presentation-将领域和表述-显示分离" class="headerlink" title="Separate Domain from Presentation (将领域和表述&#x2F;显示分离)"></a>Separate Domain from Presentation (将领域和表述&#x2F;显示分离)</h4><ul>
<li>某些GUI类之中包含了领域逻辑</li>
<li>将领域逻辑分离出来，为它们建立独立的领域类</li>
</ul>
<h4 id="Extract-Hierarchy-提炼继承体系"><a href="#Extract-Hierarchy-提炼继承体系" class="headerlink" title="Extract Hierarchy (提炼继承体系)"></a>Extract Hierarchy (提炼继承体系)</h4><ul>
<li>你有某个类做了太多工作，其中一部分工作是以大量条件表达式完成的</li>
<li>建立继承体系，以一个子类表述一种特殊情况</li>
</ul>
<h2 id="重构，复用与现实"><a href="#重构，复用与现实" class="headerlink" title="重构，复用与现实"></a>重构，复用与现实</h2><p>大约是一些重构在实际使用时的注意事项，比较碎而且涉及一些和甲方、上司的交涉之类的现实情况，目前对这一方面没什么理解，所以不整理了。<del>必然不是因为我懒</del></p>
]]></content>
      <categories>
        <category>《重构-改善既有代码的设计》</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>问题与优化汇总</title>
    <url>/2020/05/08/%E9%97%AE%E9%A2%98%E4%B8%8E%E4%BC%98%E5%8C%96%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>这篇博文诞生的原因是上一篇博文的hexo d 失效并报了谜之错误  </p>
<p>历经2小时解决后决定用此记录今后遇到的问题，同时也能记录今后的博客美化（如果有的话<br>如果有后续更新的话大概会倒序排列方便查看检索</p>
<span id="more"></span>

<h2 id="2021-02-19-18-42-优化"><a href="#2021-02-19-18-42-优化" class="headerlink" title="2021-02-19 18:42 优化"></a>2021-02-19 18:42 优化</h2><p>添加字数统计功能</p>
<h2 id="2020-05-08-20-42-优化"><a href="#2020-05-08-20-42-优化" class="headerlink" title="2020-05-08 20:42 优化"></a>2020-05-08 20:42 优化</h2><p>增加了一些小的优化</p>
<h2 id="2020-05-08-03-22-错误"><a href="#2020-05-08-03-22-错误" class="headerlink" title="2020-05-08 03:22 错误"></a>2020-05-08 03:22 错误</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error: Spawn failed</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (/Users/tmc/Documents/GitHub/hexo_tmc/node_modules/hexo-util/lib/spawn.js:51:21)</span><br><span class="line">    at ChildProcess.emit (events.js:310:20)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (internal/child_process.js:275:12)</span><br></pre></td></tr></table></figure>

<p>这一段报错并没有看出什么端倪，查看官方Issues并尝试各网上解决方案后无果。仔细观察后发现在没截到图的上文中出现了git的访问请求被拒的错误，于是删除原有ssh key并重新生成了一个新的key，绑定在了GitHub上。然后问题莫名奇妙地解决了。。报了一模一样错误的某同学通过换连手机热点的方式解决了，所以这必然是玄学bug。</p>
<h2 id="2020-07-03-03-22-错误"><a href="#2020-07-03-03-22-错误" class="headerlink" title="2020-07-03 03:22 错误"></a>2020-07-03 03:22 错误</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR Asset render failed: css/main.css</span><br><span class="line">Error: /Users/tmc/Documents/GitHub/hexo_tmc/themes/next/source/  css/_common/components/components.styl:8:3</span><br><span class="line">    4|     text-align: center;</span><br><span class="line">    5|     the-transition();</span><br><span class="line">    6|   &#125;</span><br><span class="line">    7| </span><br><span class="line">    8|   @import</span><br><span class="line">--------^</span><br><span class="line">    9| </span><br><span class="line">   10| (</span><br><span class="line">   11| hexo-config (&#x27;back2top.sidebar&#x27;) ? &#x27;back-to-top-sidebar&#x27; : &#x27;back-to-top&#x27;</span><br></pre></td></tr></table></figure>
<p>   以及另一个类似地方的类似报错，查询后发现这两个文件与GitHub上的官方版本有谜之出入，覆盖之，遂解决。</p>
]]></content>
      <categories>
        <category>博客相关</category>
      </categories>
  </entry>
</search>
