<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/favicon/site.webmanifest">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.css" integrity="sha256-vQkngPS8jiHHH0I6ABTZroZk8NPZ7b+MUReOFE9UsXQ=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"tmc0210.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.18.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="关于《重构-改善既有代码的设计》第一版的学习笔记。本节主要是书中的重构列表也即具体重构方法。因内容较多,仅简单记录名称、解释和一些值得注意的细节以供查阅。">
<meta property="og:type" content="article">
<meta property="og:title" content="《重构-改善既有代码的设计》学习笔记（二）">
<meta property="og:url" content="https://tmc0210.github.io/2020/05/13/%E3%80%8A%E9%87%8D%E6%9E%84%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/index.html">
<meta property="og:site_name" content="tmc&#39;s blogs">
<meta property="og:description" content="关于《重构-改善既有代码的设计》第一版的学习笔记。本节主要是书中的重构列表也即具体重构方法。因内容较多,仅简单记录名称、解释和一些值得注意的细节以供查阅。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-05-12T19:17:26.000Z">
<meta property="article:modified_time" content="2020-05-12T19:17:26.000Z">
<meta property="article:author" content="tmc">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="重构">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://tmc0210.github.io/2020/05/13/%E3%80%8A%E9%87%8D%E6%9E%84%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://tmc0210.github.io/2020/05/13/%E3%80%8A%E9%87%8D%E6%9E%84%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","path":"2020/05/13/《重构》学习笔记（二）/","title":"《重构-改善既有代码的设计》学习笔记（二）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《重构-改善既有代码的设计》学习笔记（二） | tmc's blogs</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">tmc's blogs</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E5%88%97%E8%A1%A8"><span class="nav-number">1.</span> <span class="nav-text">重构列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.</span> <span class="nav-text">重新组织函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Extract-Method-%E6%8F%90%E7%82%BC%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.1.</span> <span class="nav-text">Extract Method (提炼函数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Inline-Method-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.2.</span> <span class="nav-text">Inline Method (内联函数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Inline-Temp-%E5%86%85%E8%81%94%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.3.</span> <span class="nav-text">Inline Temp (内联临时变量)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-Temp-with-Query-%E4%BB%A5%E6%9F%A5%E8%AF%A2%E5%8F%96%E4%BB%A3%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.4.</span> <span class="nav-text">Replace Temp with Query (以查询取代临时变量)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Introduce-Explaining-Variable-%E5%BC%95%E5%85%A5%E8%A7%A3%E9%87%8A%E6%80%A7%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.5.</span> <span class="nav-text">Introduce Explaining Variable (引入解释性变量)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Split-Temporary-Variable-%E5%88%86%E8%A7%A3%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.6.</span> <span class="nav-text">Split Temporary Variable (分解临时变量)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Remove-Assignments-to-Parameters-%E7%A7%BB%E9%99%A4%E5%AF%B9%E5%8F%82%E6%95%B0%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="nav-number">1.1.7.</span> <span class="nav-text">Remove Assignments to Parameters (移除对参数的赋值)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-Method-with-Method-Object-%E4%BB%A5%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%8F%96%E4%BB%A3%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.8.</span> <span class="nav-text">Replace Method with Method Object (以函数对象取代函数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Substitute-Algorithm-%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.9.</span> <span class="nav-text">Substitute Algorithm (替换算法)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E6%90%AC%E7%A7%BB%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">在对象之间搬移特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Move-Method-%E6%90%AC%E7%A7%BB%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.1.</span> <span class="nav-text">Move Method (搬移函数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Move-Field-%E6%90%AC%E7%A7%BB%E5%AD%97%E6%AE%B5"><span class="nav-number">1.2.2.</span> <span class="nav-text">Move Field (搬移字段)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Extract-Class-%E6%8F%90%E7%82%BC%E7%B1%BB"><span class="nav-number">1.2.3.</span> <span class="nav-text">Extract Class (提炼类)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Inline-Class-%E5%B0%86%E7%B1%BB%E5%86%85%E8%81%94%E5%8C%96"><span class="nav-number">1.2.4.</span> <span class="nav-text">Inline Class (将类内联化)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hide-Delegate-%E9%9A%90%E8%97%8F%E2%80%9C%E5%A7%94%E6%89%98%E5%85%B3%E7%B3%BB%E2%80%9D"><span class="nav-number">1.2.5.</span> <span class="nav-text">Hide Delegate (隐藏“委托关系”)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Remove-Middle-Man-%E4%B8%AD%E9%97%B4%E4%BA%BA"><span class="nav-number">1.2.6.</span> <span class="nav-text">Remove Middle Man (中间人)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Introduce-Foreign-Method-%E5%BC%95%E5%85%A5%E5%A4%96%E5%8A%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.7.</span> <span class="nav-text">Introduce Foreign Method (引入外加函数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Introduce-Local-Extension-%E5%BC%95%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%89%A9%E5%B1%95"><span class="nav-number">1.2.8.</span> <span class="nav-text">Introduce Local Extension (引入本地扩展)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E6%95%B0%E6%8D%AE"><span class="nav-number">1.3.</span> <span class="nav-text">重新组织数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Self-Encapsulate-Field-%E8%87%AA%E5%B0%81%E8%A3%85%E5%AD%97%E6%AE%B5"><span class="nav-number">1.3.1.</span> <span class="nav-text">Self Encapsulate Field (自封装字段)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-Data-Value-with-Object-%E4%BB%A5%E5%AF%B9%E8%B1%A1%E5%8F%96%E4%BB%A3%E6%95%B0%E6%8D%AE%E5%80%BC"><span class="nav-number">1.3.2.</span> <span class="nav-text">Replace Data Value with Object (以对象取代数据值)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Change-Value-to-Reference-%E5%B0%86%E5%80%BC%E5%AF%B9%E8%B1%A1%E6%94%B9%E4%B8%BA%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.3.3.</span> <span class="nav-text">Change Value to Reference (将值对象改为引用对象)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Change-Reference-to-Value-%E5%B0%86%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%94%B9%E4%B8%BA%E5%80%BC%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.3.4.</span> <span class="nav-text">Change Reference to Value (将引用对象改为值对象)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-Array-with-Object-%E4%BB%A5%E5%AF%B9%E8%B1%A1%E5%8F%96%E4%BB%A3%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.5.</span> <span class="nav-text">Replace Array with Object (以对象取代数组)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Duplicate-Observed-Data-%E5%A4%8D%E5%88%B6-%E2%80%9C%E8%A2%AB%E7%9B%91%E8%A7%86%E6%95%B0%E6%8D%AE%E2%80%9D"><span class="nav-number">1.3.6.</span> <span class="nav-text">Duplicate Observed Data (复制 “被监视数据”)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Change-Unidirectional-Association-to-Bidirectional-%E5%B0%86%E5%8D%95%E5%90%91%E5%85%B3%E8%81%94%E6%94%B9%E4%B8%BA%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94"><span class="nav-number">1.3.7.</span> <span class="nav-text">Change Unidirectional Association to Bidirectional (将单向关联改为双向关联)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Change-Bidirectional-Association-to-Unidirectional-%E5%B0%86%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94%E6%94%B9%E4%B8%BA%E5%8D%95%E5%90%91%E5%85%B3%E8%81%94"><span class="nav-number">1.3.8.</span> <span class="nav-text">Change Bidirectional Association to Unidirectional (将双向关联改为单向关联)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-Magic-Number-with-Symbolic-Constant-%E4%BB%A5%E5%AD%97%E9%9D%A2%E5%B8%B8%E9%87%8F%E5%8F%96%E4%BB%A3%E9%AD%94%E6%B3%95%E6%95%B0"><span class="nav-number">1.3.9.</span> <span class="nav-text">Replace Magic Number with Symbolic Constant (以字面常量取代魔法数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Encapsulated-Field-%E5%B0%81%E8%A3%85%E5%AD%97%E6%AE%B5"><span class="nav-number">1.3.10.</span> <span class="nav-text">Encapsulated Field (封装字段)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Encapsulate-Collection-%E5%B0%81%E8%A3%85%E9%9B%86%E5%90%88"><span class="nav-number">1.3.11.</span> <span class="nav-text">Encapsulate Collection (封装集合)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-Record-with-Data-Class-%E4%BB%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%8F%96%E4%BB%A3%E8%AE%B0%E5%BD%95"><span class="nav-number">1.3.12.</span> <span class="nav-text">Replace Record with Data Class (以数据类取代记录)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-Type-Code-with-Class-%E4%BB%A5%E7%B1%BB%E5%8F%96%E4%BB%A3%E7%B1%BB%E5%9E%8B%E7%A0%81"><span class="nav-number">1.3.13.</span> <span class="nav-text">Replace Type Code with Class (以类取代类型码)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-Type-Code-with-Subclasses-%E4%BB%A5%E5%AD%90%E7%B1%BB%E5%8F%96%E4%BB%A3%E7%B1%BB%E5%9E%8B%E7%A0%81%EF%BC%89"><span class="nav-number">1.3.14.</span> <span class="nav-text">Replace Type Code with Subclasses (以子类取代类型码）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-Type-Code-with-State-Strategy-%E4%BB%A5-State-Strategy-%E5%8F%96%E4%BB%A3%E7%B1%BB%E5%9E%8B%E7%A0%81"><span class="nav-number">1.3.15.</span> <span class="nav-text">Replace Type Code with State&#x2F;Strategy (以 State&#x2F;Strategy 取代类型码)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-Subclass-with-Fields-%E4%BB%A5%E5%AD%97%E6%AE%B5%E5%8F%96%E4%BB%A3%E5%AD%90%E7%B1%BB"><span class="nav-number">1.3.16.</span> <span class="nav-text">Replace Subclass with Fields (以字段取代子类)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.4.</span> <span class="nav-text">简化条件表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Decompose-Conditional-%E5%88%86%E8%A7%A3%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.4.1.</span> <span class="nav-text">Decompose Conditional (分解条件表达式)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Consolidate-Conditional-Expression-%E5%90%88%E5%B9%B6%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.4.2.</span> <span class="nav-text">Consolidate Conditional Expression (合并条件表达式)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Consolidate-Duplicate-Conditional-Fragments-%E5%90%88%E5%B9%B6%E9%87%8D%E5%A4%8D%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%89%87%E6%AE%B5"><span class="nav-number">1.4.3.</span> <span class="nav-text">Consolidate Duplicate Conditional Fragments (合并重复的条件片段)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Remove-Control-Flag-%E7%A7%BB%E9%99%A4%E6%8E%A7%E5%88%B6%E6%A0%87%E8%AE%B0"><span class="nav-number">1.4.4.</span> <span class="nav-text">Remove Control Flag (移除控制标记)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-Nested-Conditional-with-Guard-Clauses-%E4%BB%A5%E5%8D%AB%E8%AF%AD%E5%8F%A5%E5%8F%96%E4%BB%A3%E5%B5%8C%E5%A5%97%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.4.5.</span> <span class="nav-text">Replace Nested Conditional with Guard Clauses (以卫语句取代嵌套表达式)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-Conditional-with-Polymorphism-%E4%BB%A5%E5%A4%9A%E6%80%81%E5%8F%96%E4%BB%A3%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.4.6.</span> <span class="nav-text">Replace Conditional with Polymorphism (以多态取代条件表达式)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Introduce-Null-Object-%E5%BC%95%E5%85%A5Null%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.4.7.</span> <span class="nav-text">Introduce Null Object (引入Null对象)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Introduce-Assertion-%E5%BC%95%E5%85%A5%E6%96%AD%E8%A8%80"><span class="nav-number">1.4.8.</span> <span class="nav-text">Introduce Assertion (引入断言)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">1.5.</span> <span class="nav-text">简化函数调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Rename-Method-%E5%87%BD%E6%95%B0%E6%94%B9%E5%90%8D"><span class="nav-number">1.5.1.</span> <span class="nav-text">Rename Method (函数改名)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Add-Parameter-%E6%B7%BB%E5%8A%A0%E5%8F%82%E6%95%B0"><span class="nav-number">1.5.2.</span> <span class="nav-text">Add Parameter (添加参数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Remove-Parameter-%E7%A7%BB%E9%99%A4%E5%8F%82%E6%95%B0"><span class="nav-number">1.5.3.</span> <span class="nav-text">Remove Parameter (移除参数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Separate-Query-from-Modifier-%E5%B0%86%E6%9F%A5%E8%AF%A2%E5%87%BD%E6%95%B0%E5%92%8C%E4%BF%AE%E6%94%B9%E5%87%BD%E6%95%B0%E5%88%86%E7%A6%BB"><span class="nav-number">1.5.4.</span> <span class="nav-text">Separate Query from Modifier (将查询函数和修改函数分离)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Parameterize-Method-%E4%BB%A4%E5%87%BD%E6%95%B0%E6%90%BA%E5%B8%A6%E5%8F%82%E6%95%B0"><span class="nav-number">1.5.5.</span> <span class="nav-text">Parameterize Method (令函数携带参数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-Parameter-with-Explicit-Methods-%E4%BB%A5%E6%98%8E%E7%A1%AE%E5%87%BD%E6%95%B0%E5%8F%96%E4%BB%A3%E5%8F%82%E6%95%B0"><span class="nav-number">1.5.6.</span> <span class="nav-text">Replace Parameter with Explicit Methods (以明确函数取代参数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Preserve-Whole-Object-%E4%BF%9D%E6%8C%81%E5%AF%B9%E8%B1%A1%E5%AE%8C%E6%95%B4"><span class="nav-number">1.5.7.</span> <span class="nav-text">Preserve Whole Object (保持对象完整)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-Parameter-with-Methods-%E4%BB%A5%E5%87%BD%E6%95%B0%E5%8F%96%E4%BB%A3%E5%8F%82%E6%95%B0"><span class="nav-number">1.5.8.</span> <span class="nav-text">Replace Parameter with Methods (以函数取代参数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Introduce-Parameter-Object-%E5%BC%95%E5%85%A5%E5%8F%82%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.5.9.</span> <span class="nav-text">Introduce Parameter Object (引入参数对象)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Remove-Setting-Method-%E7%A7%BB%E9%99%A4%E8%AE%BE%E5%80%BC%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.10.</span> <span class="nav-text">Remove Setting Method (移除设值函数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hide-Method-%E9%9A%90%E8%97%8F%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.11.</span> <span class="nav-text">Hide Method (隐藏函数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-Constructor-with-Factory-Method-%E4%BB%A5%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0%E5%8F%96%E4%BB%A3%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.12.</span> <span class="nav-text">Replace Constructor with Factory Method (以工厂函数取代构造函数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Encapsulate-Downcast-%E5%B0%81%E8%A3%85%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="nav-number">1.5.13.</span> <span class="nav-text">Encapsulate Downcast (封装向下转型)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-Error-Code-with-Exception-%E4%BB%A5%E5%BC%82%E5%B8%B8%E5%8F%96%E4%BB%A3%E9%94%99%E8%AF%AF%E7%A0%81"><span class="nav-number">1.5.14.</span> <span class="nav-text">Replace Error Code with Exception (以异常取代错误码)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-Exception-with-Test-%E4%BB%A5%E6%B5%8B%E8%AF%95%E5%8F%96%E4%BB%A3%E5%BC%82%E5%B8%B8"><span class="nav-number">1.5.15.</span> <span class="nav-text">Replace Exception with Test (以测试取代异常)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%A6%82%E6%8B%AC%E5%85%B3%E7%B3%BB"><span class="nav-number">1.6.</span> <span class="nav-text">处理概括关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Pull-Up-Field-%E5%AD%97%E6%AE%B5%E4%B8%8A%E7%A7%BB"><span class="nav-number">1.6.1.</span> <span class="nav-text">Pull Up Field (字段上移)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pull-Up-Method-%E5%87%BD%E6%95%B0%E4%B8%8A%E7%A7%BB"><span class="nav-number">1.6.2.</span> <span class="nav-text">Pull Up Method (函数上移)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pull-Up-Constructor-Body-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9C%AC%E4%BD%93%E4%B8%8A%E7%A7%BB"><span class="nav-number">1.6.3.</span> <span class="nav-text">Pull Up Constructor Body (构造函数本体上移)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Push-Down-Method-%E5%87%BD%E6%95%B0%E4%B8%8B%E7%A7%BB"><span class="nav-number">1.6.4.</span> <span class="nav-text">Push Down Method (函数下移)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Push-Down-Field-%E5%AD%97%E6%AE%B5%E4%B8%8B%E7%A7%BB"><span class="nav-number">1.6.5.</span> <span class="nav-text">Push Down Field (字段下移)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Extract-Superclass-%E6%8F%90%E7%82%BC%E8%B6%85%E7%B1%BB"><span class="nav-number">1.6.6.</span> <span class="nav-text">Extract Superclass (提炼超类)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Extract-Interface-%E6%8F%90%E7%82%BC%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.6.7.</span> <span class="nav-text">Extract Interface (提炼接口)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Collapse-Hierarchy-%E6%8A%98%E5%8F%A0%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="nav-number">1.6.8.</span> <span class="nav-text">Collapse Hierarchy (折叠继承体系)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Form-TemPlate-Method-%E5%A1%91%E9%80%A0%E6%A8%A1%E7%89%88%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.9.</span> <span class="nav-text">Form TemPlate Method (塑造模版函数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-Inheritance-with-Delegation-%E4%BB%A5%E5%A7%94%E6%89%98%E5%8F%96%E4%BB%A3%E7%BB%A7%E6%89%BF"><span class="nav-number">1.6.10.</span> <span class="nav-text">Replace Inheritance with Delegation (以委托取代继承)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-Delegation-with-Inheritance-%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%8F%96%E4%BB%A3%E5%A7%94%E6%89%98"><span class="nav-number">1.6.11.</span> <span class="nav-text">Replace Delegation with Inheritance (以继承取代委托)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E5%9E%8B%E9%87%8D%E6%9E%84"><span class="nav-number">1.7.</span> <span class="nav-text">大型重构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Tease-Apart-Inheritance-%E6%A2%B3%E7%90%86%E5%B9%B6%E5%88%86%E8%A7%A3%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="nav-number">1.7.1.</span> <span class="nav-text">Tease Apart Inheritance (梳理并分解继承体系)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Convert-Procedural-Design-to-Objects-%E5%B0%86%E8%BF%87%E7%A8%8B%E5%8C%96%E8%AE%BE%E8%AE%A1%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.7.2.</span> <span class="nav-text">Convert Procedural Design to Objects (将过程化设计转化为对象设计)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Separate-Domain-from-Presentation-%E5%B0%86%E9%A2%86%E5%9F%9F%E5%92%8C%E8%A1%A8%E8%BF%B0-%E6%98%BE%E7%A4%BA%E5%88%86%E7%A6%BB"><span class="nav-number">1.7.3.</span> <span class="nav-text">Separate Domain from Presentation (将领域和表述&#x2F;显示分离)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Extract-Hierarchy-%E6%8F%90%E7%82%BC%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="nav-number">1.7.4.</span> <span class="nav-text">Extract Hierarchy (提炼继承体系)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%EF%BC%8C%E5%A4%8D%E7%94%A8%E4%B8%8E%E7%8E%B0%E5%AE%9E"><span class="nav-number">2.</span> <span class="nav-text">重构，复用与现实</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tmc</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/tmc0210" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tmc0210" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:494521535@qq.com" title="E-Mail → mailto:494521535@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://blog.holdice.club/" title="https:&#x2F;&#x2F;blog.holdice.club&#x2F;" rel="noopener" target="_blank">holdice's blogs</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://shiraha.cn/" title="https:&#x2F;&#x2F;shiraha.cn&#x2F;" rel="noopener" target="_blank">七海の参考書</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://blog.csdn.net/qq_39119496/article/details/103372437" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_39119496&#x2F;article&#x2F;details&#x2F;103372437" rel="noopener" target="_blank">Ashmore</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tmc0210.github.io/2020/05/13/%E3%80%8A%E9%87%8D%E6%9E%84%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tmc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tmc's blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="《重构-改善既有代码的设计》学习笔记（二） | tmc's blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《重构-改善既有代码的设计》学习笔记（二）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-13 03:17:26" itemprop="dateCreated datePublished" datetime="2020-05-13T03:17:26+08:00">2020-05-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%8A%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E3%80%8B/" itemprop="url" rel="index"><span itemprop="name">《重构-改善既有代码的设计》</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>关于《重构-改善既有代码的设计》第一版的学习笔记。本节主要是书中的重构列表也即具体重构方法。因内容较多,仅简单记录名称、解释和一些值得注意的细节以供查阅。</p>
<span id="more"></span>

<h2 id="重构列表"><a href="#重构列表" class="headerlink" title="重构列表"></a>重构列表</h2><h3 id="重新组织函数"><a href="#重新组织函数" class="headerlink" title="重新组织函数"></a>重新组织函数</h3><h4 id="Extract-Method-提炼函数"><a href="#Extract-Method-提炼函数" class="headerlink" title="Extract Method (提炼函数)"></a>Extract Method (提炼函数)</h4><ul>
<li>你有一段代码可以被组织在一起并独立出来  </li>
<li>将这段代码放进一个独立函数中，并让函数名称解释该函数的用途</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void printOwing(double amount)</span><br><span class="line">&#123;</span><br><span class="line">    printBanner();</span><br><span class="line"></span><br><span class="line">    // print details</span><br><span class="line">    System.out.println(&quot;name:&quot; + _name);</span><br><span class="line">    System.out.println(&quot;amount&quot; + _amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void printOwing(double amount)</span><br><span class="line">&#123;</span><br><span class="line">    printBanner();</span><br><span class="line">    printDetails(amount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printDetails(double amount)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(&quot;name&quot; + _name);</span><br><span class="line">    System.out.println(&quot;amount&quot; + amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意目标代码中的局部变量。如果需要对局部变量进行再次赋值并使用，提炼出的函数可以使用参数以及返回值。</p>
<h4 id="Inline-Method-内联函数"><a href="#Inline-Method-内联函数" class="headerlink" title="Inline Method (内联函数)"></a>Inline Method (内联函数)</h4><ul>
<li>一个函数的本体和名称同样清楚易懂  </li>
<li>在函数调用点插入函数本体，然后移除该函数</li>
</ul>
<p>与上一条完全相反，这里是去除不必要的间接性。另一种情况是需要整理大量不甚合理的小函数时，先全部内联到一个大函数中，再重新进行提炼。  </p>
<h4 id="Inline-Temp-内联临时变量"><a href="#Inline-Temp-内联临时变量" class="headerlink" title="Inline Temp (内联临时变量)"></a>Inline Temp (内联临时变量)</h4><ul>
<li>你有一个临时变量，只被一个简单表达式赋值一次，而妨碍了其他重构手法</li>
<li>将所有对该变量的引用动作，替换为对它赋值的那个表达式自身</li>
</ul>
<p>多半作为下一条的一部分使用，通常不会有什么危害，但是如果妨碍了其他重构思路，就可以将其内联化。使用时可以通过将这个临时变量设置为final以检查其是否只被赋值一次。</p>
<h4 id="Replace-Temp-with-Query-以查询取代临时变量"><a href="#Replace-Temp-with-Query-以查询取代临时变量" class="headerlink" title="Replace Temp with Query (以查询取代临时变量)"></a>Replace Temp with Query (以查询取代临时变量)</h4><ul>
<li>你的程序以一个临时变量保存某一表达式的运算结果</li>
<li>将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可以被其他函数使用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double basePrice = _quantity * _itemPrice;</span><br><span class="line">    if (basePrice &gt; 1000)</span><br><span class="line">        return basePrice * 0.95;</span><br><span class="line">    else</span><br><span class="line">        return basePrice * 0.95</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (basePrice() &gt; 1000)</span><br><span class="line">    return basePrice() * 0.95;</span><br><span class="line">else</span><br><span class="line">    return basePrice() * 0.95</span><br><span class="line">...</span><br><span class="line">double basePrice()</span><br><span class="line">&#123;</span><br><span class="line">    return _quantity * _itemPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是让一个函数中的表达式计算可以被其他函数使用。通常是 Extra Method 前的步骤。运用此手法可能会产生性能问题，但是通常可以忽略不计，或是可以在性能优化阶段解决。</p>
<h4 id="Introduce-Explaining-Variable-引入解释性变量"><a href="#Introduce-Explaining-Variable-引入解释性变量" class="headerlink" title="Introduce Explaining Variable (引入解释性变量)"></a>Introduce Explaining Variable (引入解释性变量)</h4><ul>
<li>你有一个复杂的表达式</li>
<li>将该复杂表达式(或其中一部分)的结果放进一个临时变量，以此变量名称来解释表达式用途。</li>
</ul>
<p>也是和上一条相反。当表达式非常复杂难以阅读时使用。当然，也可以使用 Extract Method。何时使用二者可以根据具体工作量来判断。</p>
<h4 id="Split-Temporary-Variable-分解临时变量"><a href="#Split-Temporary-Variable-分解临时变量" class="headerlink" title="Split Temporary Variable (分解临时变量)"></a>Split Temporary Variable (分解临时变量)</h4><ul>
<li>你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。</li>
<li>针对每次赋值，创造一个独立，对应的临时变量</li>
</ul>
<p>除了循环变量和结果收集变量。临时变量大多不应被多次赋值。也即临时变量不应承担多个责任。</p>
<h4 id="Remove-Assignments-to-Parameters-移除对参数的赋值"><a href="#Remove-Assignments-to-Parameters-移除对参数的赋值" class="headerlink" title="Remove Assignments to Parameters (移除对参数的赋值)"></a>Remove Assignments to Parameters (移除对参数的赋值)</h4><ul>
<li>代码对一个参数进行赋值</li>
<li>以一个临时变量取代该参数的位置</li>
</ul>
<p>以下为一段java代码(采用按值传递)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void aMethod(Object foo)</span><br><span class="line">&#123;</span><br><span class="line">    foo.modifyInSomeWay;    //可</span><br><span class="line">    foo = anotherObject;    //不可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这导致混用按值传递和按引用传递，降低代码清晰度。</p>
<h4 id="Replace-Method-with-Method-Object-以函数对象取代函数"><a href="#Replace-Method-with-Method-Object-以函数对象取代函数" class="headerlink" title="Replace Method with Method Object (以函数对象取代函数)"></a>Replace Method with Method Object (以函数对象取代函数)</h4><ul>
<li>你有一个大型函数，其中对局部变量的引用使你无法采用 Extract Method</li>
<li>将这个函数放进一个单独对象中，如此一来局部对象就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。</li>
</ul>
<h4 id="Substitute-Algorithm-替换算法"><a href="#Substitute-Algorithm-替换算法" class="headerlink" title="Substitute Algorithm (替换算法)"></a>Substitute Algorithm (替换算法)</h4><ul>
<li>你想要将某个算法替换为另一个更清晰的算法</li>
<li>将函数本体替换为另一个算法</li>
</ul>
<h3 id="在对象之间搬移特性"><a href="#在对象之间搬移特性" class="headerlink" title="在对象之间搬移特性"></a>在对象之间搬移特性</h3><h4 id="Move-Method-搬移函数"><a href="#Move-Method-搬移函数" class="headerlink" title="Move Method (搬移函数)"></a>Move Method (搬移函数)</h4><ul>
<li>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流:调用后者，或被后者调用</li>
<li>在该函数最常引用的类中建立一个有类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移除。</li>
</ul>
<h4 id="Move-Field-搬移字段"><a href="#Move-Field-搬移字段" class="headerlink" title="Move Field (搬移字段)"></a>Move Field (搬移字段)</h4><ul>
<li>你的程序中，某个字段被其所驻类之外的另一个类更多地用到</li>
<li>在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段</li>
</ul>
<h4 id="Extract-Class-提炼类"><a href="#Extract-Class-提炼类" class="headerlink" title="Extract Class (提炼类)"></a>Extract Class (提炼类)</h4><ul>
<li>某个类做了应该由两个类做的事</li>
<li>建立一个新类，将相关的字段和函数从旧类搬移到新类</li>
</ul>
<p>信号之一是类的子类化方式出现问题，如果子类化只影响了类的部分特性或类的不同特性需要以不同方式来子类化，这意味着需要分解原来的类。</p>
<h4 id="Inline-Class-将类内联化"><a href="#Inline-Class-将类内联化" class="headerlink" title="Inline Class (将类内联化)"></a>Inline Class (将类内联化)</h4><ul>
<li>某个类没有做太多事情</li>
<li>将这个类的所有特性搬移到另一个类中，然后移除原类</li>
</ul>
<p><del>看起来我需要被内联</del><br>这与上一条相反，当类不再有单独存在的理由时，应当将该类移入它的最频繁用户中。</p>
<h4 id="Hide-Delegate-隐藏“委托关系”"><a href="#Hide-Delegate-隐藏“委托关系”" class="headerlink" title="Hide Delegate (隐藏“委托关系”)"></a>Hide Delegate (隐藏“委托关系”)</h4><ul>
<li>客户通过一个委托类来调用另一个对象</li>
<li>在服务类上建立客户所需的所有函数，用以隐藏委托关系</li>
</ul>
<p>可以在服务器对象上放置一个简单的委托函数，将委托关系隐藏起来，从而去除一些依赖关系。这样即使发生委托关系上的方法，变化也将被限制在服务对象中，不会波及客户。</p>
<h4 id="Remove-Middle-Man-中间人"><a href="#Remove-Middle-Man-中间人" class="headerlink" title="Remove Middle Man (中间人)"></a>Remove Middle Man (中间人)</h4><ul>
<li>某个类做了过多的简单委托动作</li>
<li>让客户直接调用受托类</li>
</ul>
<p>与上一条相反，随着受托类的特性和功能越来越多，服务类会完全变成“中间人”，此时你就应该让客户直接调用受托类。使用这一条和上一条可以保证隐藏的程度是合适。</p>
<h4 id="Introduce-Foreign-Method-引入外加函数"><a href="#Introduce-Foreign-Method-引入外加函数" class="headerlink" title="Introduce Foreign Method (引入外加函数)"></a>Introduce Foreign Method (引入外加函数)</h4><ul>
<li>你需要为提供服务的类增加一个函数，但你无法修改这个类</li>
<li>在客户类中建立一个函数，并以第一参数形式传入一个服务类实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date newStart = new Date(previousEnd.getYear(),previousEnd.getMonth(),previousEnd.getDate() + 1);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date newStart = nextDay(previousEnd)</span><br></pre></td></tr></table></figure>

<p>正在使用一个类时，如果你需要一项服务而类无法供应，此时如果你能修改源码，可以自行添加一个新函数，如果不能，就要在客户端编码，补足所需的函数。明确信号是这个函数本应在服务类中实现，如果有可能，这些函数仍然应该放回到服务类。</p>
<h4 id="Introduce-Local-Extension-引入本地扩展"><a href="#Introduce-Local-Extension-引入本地扩展" class="headerlink" title="Introduce Local Extension (引入本地扩展)"></a>Introduce Local Extension (引入本地扩展)</h4><ul>
<li>你需要为服务类提供一些额外函数，但你无法修改这个类</li>
<li>建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。</li>
</ul>
<p>和上一条的情况类似，如果你需要少数函数，你可以使用上一条的方法，而如果你需要加入多个函数，就可以使用本地扩展。例如子类化和包装。作者通常采取子类。</p>
<h3 id="重新组织数据"><a href="#重新组织数据" class="headerlink" title="重新组织数据"></a>重新组织数据</h3><h4 id="Self-Encapsulate-Field-自封装字段"><a href="#Self-Encapsulate-Field-自封装字段" class="headerlink" title="Self Encapsulate Field (自封装字段)"></a>Self Encapsulate Field (自封装字段)</h4><ul>
<li>你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙</li>
<li>为这个字段建立取值&#x2F;设值函数，并且只以这些函数来访问字段</li>
</ul>
<p>如果一个类中有private字段，是否可以自由访问，还是应该使用访问函数间接访问，有两个说法。<br>间接访问变量的函数的好处是，子类可以通过覆写一个函数而改变获取数据的途径；它还支持更灵活的数据管理方式，例如延迟初始化。<br>直接访问变量的好处则是，代码比较容易阅读。<br>如果你想要访问超类中的一个字段，却又想在子类中将对这个变量的访问改为一个计算后的值，就应该使用这一方法。</p>
<h4 id="Replace-Data-Value-with-Object-以对象取代数据值"><a href="#Replace-Data-Value-with-Object-以对象取代数据值" class="headerlink" title="Replace Data Value with Object (以对象取代数据值)"></a>Replace Data Value with Object (以对象取代数据值)</h4><ul>
<li>你有一个数据项，需要与其他数据和行为一起使用才有意义</li>
<li>将数据项变成对象</li>
</ul>
<p>开发初期，对于电话号码一类的数据可能会出现，早期使用字符串表示，但后来发现需要抽取区号等行为。如果这样的数据项只有一两个，你可以把相关函数放进数据项所属的对象里；但是 Duplicate Code 和 Feature Envy bad smell就可能会出现，这时就需要把数据值变成对象。</p>
<h4 id="Change-Value-to-Reference-将值对象改为引用对象"><a href="#Change-Value-to-Reference-将值对象改为引用对象" class="headerlink" title="Change Value to Reference (将值对象改为引用对象)"></a>Change Value to Reference (将值对象改为引用对象)</h4><ul>
<li>你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象</li>
</ul>
<h4 id="Change-Reference-to-Value-将引用对象改为值对象"><a href="#Change-Reference-to-Value-将引用对象改为值对象" class="headerlink" title="Change Reference to Value (将引用对象改为值对象)"></a>Change Reference to Value (将引用对象改为值对象)</h4><ul>
<li>你有一个引用对象，很小且不可变，而且不易管理</li>
</ul>
<p>和上一条相反。如果引用对象开始难以使用，就可能需要改为值对象。<br>值对象的重要特性是不可变(immutable)的。例如如果用Money类表示钱的概念，那Money类通常是一个不可变的值对象，这不意味着你的薪资不能改变，而是说改变薪资需要使用新的Money类对象代替而非修改现有的Money类。  </p>
<h4 id="Replace-Array-with-Object-以对象取代数组"><a href="#Replace-Array-with-Object-以对象取代数组" class="headerlink" title="Replace Array with Object (以对象取代数组)"></a>Replace Array with Object (以对象取代数组)</h4><ul>
<li>你有一个数组，其中的元素各自代表不同的东西</li>
<li>以对象替换数组。对于数组中的每个元素，以一个字段来表示</li>
</ul>
<h4 id="Duplicate-Observed-Data-复制-“被监视数据”"><a href="#Duplicate-Observed-Data-复制-“被监视数据”" class="headerlink" title="Duplicate Observed Data (复制 “被监视数据”)"></a>Duplicate Observed Data (复制 “被监视数据”)</h4><ul>
<li>你有一些领域置身于GUI控件中，而领域函数需要访问这些数据</li>
<li>将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据</li>
</ul>
<h4 id="Change-Unidirectional-Association-to-Bidirectional-将单向关联改为双向关联"><a href="#Change-Unidirectional-Association-to-Bidirectional-将单向关联改为双向关联" class="headerlink" title="Change Unidirectional Association to Bidirectional (将单向关联改为双向关联)"></a>Change Unidirectional Association to Bidirectional (将单向关联改为双向关联)</h4><ul>
<li>两个类都需要使用对方特性，但其间只有一条单向连接</li>
<li>添加一个反向指针，并使修改函数能够同时更新两条连接</li>
</ul>
<h4 id="Change-Bidirectional-Association-to-Unidirectional-将双向关联改为单向关联"><a href="#Change-Bidirectional-Association-to-Unidirectional-将双向关联改为单向关联" class="headerlink" title="Change Bidirectional Association to Unidirectional (将双向关联改为单向关联)"></a>Change Bidirectional Association to Unidirectional (将双向关联改为单向关联)</h4><ul>
<li>两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性</li>
<li>去除不必要的关联</li>
</ul>
<h4 id="Replace-Magic-Number-with-Symbolic-Constant-以字面常量取代魔法数"><a href="#Replace-Magic-Number-with-Symbolic-Constant-以字面常量取代魔法数" class="headerlink" title="Replace Magic Number with Symbolic Constant (以字面常量取代魔法数)"></a>Replace Magic Number with Symbolic Constant (以字面常量取代魔法数)</h4><ul>
<li>你有一个字面数值，带有特别含义</li>
<li>创造一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量</li>
</ul>
<h4 id="Encapsulated-Field-封装字段"><a href="#Encapsulated-Field-封装字段" class="headerlink" title="Encapsulated Field (封装字段)"></a>Encapsulated Field (封装字段)</h4><ul>
<li>你的类中存在一个public字段</li>
<li>将它声明为private，并提供相应的访问函数</li>
</ul>
<h4 id="Encapsulate-Collection-封装集合"><a href="#Encapsulate-Collection-封装集合" class="headerlink" title="Encapsulate Collection (封装集合)"></a>Encapsulate Collection (封装集合)</h4><ul>
<li>有个函数返回一个集合</li>
<li>让这个函数返回该集合的一个只读副本，并在这个类中提供添加&#x2F;移除集合元素的函数</li>
</ul>
<h4 id="Replace-Record-with-Data-Class-以数据类取代记录"><a href="#Replace-Record-with-Data-Class-以数据类取代记录" class="headerlink" title="Replace Record with Data Class (以数据类取代记录)"></a>Replace Record with Data Class (以数据类取代记录)</h4><ul>
<li>你需要面对传统编程环境中的记录结构</li>
<li>为该记录创建一个“哑”数据对象</li>
</ul>
<p>创建一个接口类以处理外来的记录型结构(所以记录式结构是什么)</p>
<h4 id="Replace-Type-Code-with-Class-以类取代类型码"><a href="#Replace-Type-Code-with-Class-以类取代类型码" class="headerlink" title="Replace Type Code with Class (以类取代类型码)"></a>Replace Type Code with Class (以类取代类型码)</h4><ul>
<li>类之中有一个数值类型码，但它并不影响类的行为</li>
<li>以一个新的类替换该数值类型码</li>
</ul>
<h4 id="Replace-Type-Code-with-Subclasses-以子类取代类型码）"><a href="#Replace-Type-Code-with-Subclasses-以子类取代类型码）" class="headerlink" title="Replace Type Code with Subclasses (以子类取代类型码）"></a>Replace Type Code with Subclasses (以子类取代类型码）</h4><ul>
<li>你有一个不可变的类型码，它会影响类的行为</li>
<li>以子类取代这个类型码</li>
</ul>
<h4 id="Replace-Type-Code-with-State-Strategy-以-State-Strategy-取代类型码"><a href="#Replace-Type-Code-with-State-Strategy-以-State-Strategy-取代类型码" class="headerlink" title="Replace Type Code with State&#x2F;Strategy (以 State&#x2F;Strategy 取代类型码)"></a>Replace Type Code with State&#x2F;Strategy (以 State&#x2F;Strategy 取代类型码)</h4><ul>
<li>你有一个类型码，它会影响类的行为，但你无法通过继承手法消除它</li>
<li>以状态对象取代类型码</li>
</ul>
<p>如果类型码的值在对象生命周期中发生变化或其他原因使得宿主类不能被继承，可以使用本重构</p>
<h4 id="Replace-Subclass-with-Fields-以字段取代子类"><a href="#Replace-Subclass-with-Fields-以字段取代子类" class="headerlink" title="Replace Subclass with Fields (以字段取代子类)"></a>Replace Subclass with Fields (以字段取代子类)</h4><ul>
<li>你的各个子类的唯一差别只在“返回常量数据”的函数上</li>
<li>修改这个函数，使他们返回超类中的某个(新增)字段，然后销毁子类</li>
</ul>
<h3 id="简化条件表达式"><a href="#简化条件表达式" class="headerlink" title="简化条件表达式"></a>简化条件表达式</h3><h4 id="Decompose-Conditional-分解条件表达式"><a href="#Decompose-Conditional-分解条件表达式" class="headerlink" title="Decompose Conditional (分解条件表达式)"></a>Decompose Conditional (分解条件表达式)</h4><ul>
<li>你有一个复杂的条件 (if - then - else)</li>
<li>从 if，then，else 三个段落中分别提炼出独立函数</li>
</ul>
<h4 id="Consolidate-Conditional-Expression-合并条件表达式"><a href="#Consolidate-Conditional-Expression-合并条件表达式" class="headerlink" title="Consolidate Conditional Expression (合并条件表达式)"></a>Consolidate Conditional Expression (合并条件表达式)</h4><ul>
<li>你有一系列条件测试，都得到相同结果</li>
<li>将这些测试合并为一个条件表达式，并将这个条件式提炼成为一个独立函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">double disabilityAmount()</span><br><span class="line">&#123;</span><br><span class="line">    if (_seniority &lt; 2) return 0;</span><br><span class="line">    if (_monthsDisabled &lt; 12) return 0;</span><br><span class="line">    if (_isPartTime) return 0;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double disabilityAmount()</span><br><span class="line">&#123;</span><br><span class="line">    if (isNotEligableForDisability()) return 0;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Consolidate-Duplicate-Conditional-Fragments-合并重复的条件片段"><a href="#Consolidate-Duplicate-Conditional-Fragments-合并重复的条件片段" class="headerlink" title="Consolidate Duplicate Conditional Fragments (合并重复的条件片段)"></a>Consolidate Duplicate Conditional Fragments (合并重复的条件片段)</h4><ul>
<li>在条件表达式的每个分支上有着相同的一段代码</li>
<li>将这段重复代码搬移到条件表达式之外</li>
</ul>
<h4 id="Remove-Control-Flag-移除控制标记"><a href="#Remove-Control-Flag-移除控制标记" class="headerlink" title="Remove Control Flag (移除控制标记)"></a>Remove Control Flag (移除控制标记)</h4><ul>
<li>在一系列布尔表达式中，某个变量带有”控制标记”(control flag)的作用</li>
<li>以 break 语句或 return 语句取代控制标记<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void checkSecurity(String people)</span><br><span class="line">&#123;</span><br><span class="line">    boolean found = false;</span><br><span class="line">    for (int i = 0; i &lt; people.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!found)</span><br><span class="line">        &#123;</span><br><span class="line">            if (people(i).equals(&quot;Don&quot;))</span><br><span class="line">            &#123;</span><br><span class="line">                sendAlert();</span><br><span class="line">                found = true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (people(i).equals(&quot;John&quot;))</span><br><span class="line">            &#123;</span><br><span class="line">                sendAlert();</span><br><span class="line">                found = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void checkSecurity(String[] people)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; people.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (people(i).equals(&quot;Don&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            sendAlert();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (people(i).equals(&quot;John&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            sendAlert();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两段书中示例的代码在同时满足两个条件时的输出是不一致的，不过对于示例中检测两个嫌疑人名字的情形应该不会出现这种情况。<br>如果这里的found同时用于输出结果，可以使用 return 重构</p>
<h4 id="Replace-Nested-Conditional-with-Guard-Clauses-以卫语句取代嵌套表达式"><a href="#Replace-Nested-Conditional-with-Guard-Clauses-以卫语句取代嵌套表达式" class="headerlink" title="Replace Nested Conditional with Guard Clauses (以卫语句取代嵌套表达式)"></a>Replace Nested Conditional with Guard Clauses (以卫语句取代嵌套表达式)</h4><ul>
<li>函数中的条件逻辑使人难以看清正常的执行路径</li>
<li>使用卫语句表现所有特殊情况<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">double getPayAmount()</span><br><span class="line">&#123;</span><br><span class="line">    double result;</span><br><span class="line">    if (_isDead)</span><br><span class="line">    &#123;</span><br><span class="line">        result = deadAmount();</span><br><span class="line">    &#125;</span><br><span class="line">    else </span><br><span class="line">    &#123;</span><br><span class="line">        if (_isSeparted) </span><br><span class="line">        &#123;</span><br><span class="line">            result = separatedAmount();</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (_isRetired) result = retiredAmount();</span><br><span class="line">            else result = normalPayAmount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">double getPayAmount()</span><br><span class="line">&#123;</span><br><span class="line">    if (_isDead) return deadAmount();</span><br><span class="line">    if (_isSeparated) return separatedAmount();</span><br><span class="line">    if (_isRetired) return retiredAmount();</span><br><span class="line">    return normalPayAmount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>条件表达式通常有两种表现形式，一种是所有分支都是正常行为，另一种是只有一种是正常行为，其他都是特殊情况。<br>对于第一种就应该使用if-else语句，而对于第二种就应当使用卫语句。卫语句通常从函数中返回或抛异常。</p>
<h4 id="Replace-Conditional-with-Polymorphism-以多态取代条件表达式"><a href="#Replace-Conditional-with-Polymorphism-以多态取代条件表达式" class="headerlink" title="Replace Conditional with Polymorphism (以多态取代条件表达式)"></a>Replace Conditional with Polymorphism (以多态取代条件表达式)</h4><ul>
<li>你手上有个条件表达式，它根据对象类型的不同而选择不同的行为</li>
<li>将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数</li>
</ul>
<h4 id="Introduce-Null-Object-引入Null对象"><a href="#Introduce-Null-Object-引入Null对象" class="headerlink" title="Introduce Null Object (引入Null对象)"></a>Introduce Null Object (引入Null对象)</h4><ul>
<li>你需要再三检查某对象是否为null</li>
<li>将null值替换为null对象</li>
</ul>
<p>也即引入 Null Object 设计模式。<br>例如对于 Customer 对象和持有的 getPlan 方法，可以建立空对象类 Null Customer 继承 Customer 类，并用空对象对应行为替换 Null Customer 类的 getPlan 方法。<br>实际使用时，注意在源类和子类中加入 isNull() 函数,前者返回 false ，后者的 isNull() 返回true。也可以建立 nullable 接口将 isNull() 放在其中。之后所有将源对象与 null 比较的地方就可以调用 isNull() 函数。</p>
<h4 id="Introduce-Assertion-引入断言"><a href="#Introduce-Assertion-引入断言" class="headerlink" title="Introduce Assertion (引入断言)"></a>Introduce Assertion (引入断言)</h4><ul>
<li>某一段代码需要对程序状态做出某种假设</li>
<li>以断言明确表现这种假设<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">double getExpenseLimit()</span><br><span class="line">&#123;</span><br><span class="line">    // should have either expense limit or a primary project</span><br><span class="line">    return (_expenseLimit != NULL_EXPENSE) ?</span><br><span class="line">        _expenseLimit:</span><br><span class="line">        _primaryProject.getMemberExpenseLimit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">double getExpenseLimit()</span><br><span class="line">&#123;</span><br><span class="line">    Assert.isTure(_expenseLimit != NULL_EXPENSE || _primaryProject != null)</span><br><span class="line">    return (_expenseLimit != NULL_EXPENSE) ?</span><br><span class="line">        _expenseLimit:</span><br><span class="line">        _primaryProject.getMemberExpenseLimit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="简化函数调用"><a href="#简化函数调用" class="headerlink" title="简化函数调用"></a>简化函数调用</h3><h4 id="Rename-Method-函数改名"><a href="#Rename-Method-函数改名" class="headerlink" title="Rename Method (函数改名)"></a>Rename Method (函数改名)</h4><ul>
<li>函数的名称未能揭示函数的用途</li>
<li>修改函数名称</li>
</ul>
<p>作者提倡的好方法是先考虑给这个函数写上一句怎样的注释，再想办法将注释变成函数名称。</p>
<h4 id="Add-Parameter-添加参数"><a href="#Add-Parameter-添加参数" class="headerlink" title="Add Parameter (添加参数)"></a>Add Parameter (添加参数)</h4><ul>
<li>某个函数需要从调用端得到更多信息</li>
<li>为此函数添加一个对象参数，让该对象带进函数所需信息</li>
</ul>
<h4 id="Remove-Parameter-移除参数"><a href="#Remove-Parameter-移除参数" class="headerlink" title="Remove Parameter (移除参数)"></a>Remove Parameter (移除参数)</h4><ul>
<li>函数本体不再需要某个参数</li>
<li>将该参数去除</li>
</ul>
<h4 id="Separate-Query-from-Modifier-将查询函数和修改函数分离"><a href="#Separate-Query-from-Modifier-将查询函数和修改函数分离" class="headerlink" title="Separate Query from Modifier (将查询函数和修改函数分离)"></a>Separate Query from Modifier (将查询函数和修改函数分离)</h4><ul>
<li>某个函数既返回对象状态值，又修改对象状态</li>
<li>建立两个不同的函数，其中一个负责查询，另一个负责修改</li>
</ul>
<p>也即分离 getter setter</p>
<h4 id="Parameterize-Method-令函数携带参数"><a href="#Parameterize-Method-令函数携带参数" class="headerlink" title="Parameterize Method (令函数携带参数)"></a>Parameterize Method (令函数携带参数)</h4><ul>
<li>若干函数做了类似的工作，但在函数本体中却包括了不同的值</li>
<li>建立单一函数，以参数表达那些不同的值</li>
</ul>
<h4 id="Replace-Parameter-with-Explicit-Methods-以明确函数取代参数"><a href="#Replace-Parameter-with-Explicit-Methods-以明确函数取代参数" class="headerlink" title="Replace Parameter with Explicit Methods (以明确函数取代参数)"></a>Replace Parameter with Explicit Methods (以明确函数取代参数)</h4><ul>
<li>你有一个函数，其中完全取决于参数值而采取不同行为</li>
<li>针对该参数的每一个可能值，建立一个独立函数</li>
</ul>
<h4 id="Preserve-Whole-Object-保持对象完整"><a href="#Preserve-Whole-Object-保持对象完整" class="headerlink" title="Preserve Whole Object (保持对象完整)"></a>Preserve Whole Object (保持对象完整)</h4><ul>
<li>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数</li>
<li>改为传递整个对象</li>
</ul>
<h4 id="Replace-Parameter-with-Methods-以函数取代参数"><a href="#Replace-Parameter-with-Methods-以函数取代参数" class="headerlink" title="Replace Parameter with Methods (以函数取代参数)"></a>Replace Parameter with Methods (以函数取代参数)</h4><ul>
<li>对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能够调用前一个函数</li>
<li>让参数接受者去除该项参数，并直接调用前一个函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int basePrice = _quantity * _itemPrice;</span><br><span class="line">discountLevel = getDiscountLevel();</span><br><span class="line">double finalPrice = discountedPrice(basePrice,discountLevel);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int basePrice = _quantity * _itemPrice;</span><br><span class="line">double finalPrice = discountedPrice(basePrice);</span><br></pre></td></tr></table></figure>

<h4 id="Introduce-Parameter-Object-引入参数对象"><a href="#Introduce-Parameter-Object-引入参数对象" class="headerlink" title="Introduce Parameter Object (引入参数对象)"></a>Introduce Parameter Object (引入参数对象)</h4><ul>
<li>某些参数总是很自然地同时出现</li>
<li>以一个对象取代这些参数</li>
</ul>
<h4 id="Remove-Setting-Method-移除设值函数"><a href="#Remove-Setting-Method-移除设值函数" class="headerlink" title="Remove Setting Method (移除设值函数)"></a>Remove Setting Method (移除设值函数)</h4><ul>
<li>类中的某个字段应该在对象创建时被设值，然后就不再改变</li>
<li>去掉该字段的所有设值函数</li>
</ul>
<h4 id="Hide-Method-隐藏函数"><a href="#Hide-Method-隐藏函数" class="headerlink" title="Hide Method (隐藏函数)"></a>Hide Method (隐藏函数)</h4><ul>
<li>有一个函数，从来没有被其他任何类用到</li>
<li>将这个函数修改为 private</li>
</ul>
<h4 id="Replace-Constructor-with-Factory-Method-以工厂函数取代构造函数"><a href="#Replace-Constructor-with-Factory-Method-以工厂函数取代构造函数" class="headerlink" title="Replace Constructor with Factory Method (以工厂函数取代构造函数)"></a>Replace Constructor with Factory Method (以工厂函数取代构造函数)</h4><ul>
<li>你希望在创建对象时不仅仅是做简单的建构动作</li>
<li>将构造函数替换为工厂函数</li>
</ul>
<p>最显而易见的用途是在派生子类的过程中以工厂函数取代类型码，或者构造函数的功能不能满足你的需要，也可以用工厂函数替代它。</p>
<h4 id="Encapsulate-Downcast-封装向下转型"><a href="#Encapsulate-Downcast-封装向下转型" class="headerlink" title="Encapsulate Downcast (封装向下转型)"></a>Encapsulate Downcast (封装向下转型)</h4><ul>
<li>某个函数返回的对象，需要由函数调用者执行向下转型(downcast)</li>
<li>将向下转型动作移到函数上</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object lastReading()</span><br><span class="line">&#123;</span><br><span class="line">    return readings.lastElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object lastReading()</span><br><span class="line">&#123;</span><br><span class="line">    return (Reading) reading.lastElment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Replace-Error-Code-with-Exception-以异常取代错误码"><a href="#Replace-Error-Code-with-Exception-以异常取代错误码" class="headerlink" title="Replace Error Code with Exception (以异常取代错误码)"></a>Replace Error Code with Exception (以异常取代错误码)</h4><ul>
<li>某个函数返回一个特定的代码，用以表示某种错误情况</li>
<li>改用异常</li>
</ul>
<h4 id="Replace-Exception-with-Test-以测试取代异常"><a href="#Replace-Exception-with-Test-以测试取代异常" class="headerlink" title="Replace Exception with Test (以测试取代异常)"></a>Replace Exception with Test (以测试取代异常)</h4><ul>
<li>面对一个调用者可以预先检查的条件，你抛出了一个异常</li>
<li>修改调用者，使它在调用函数之前先做检查</li>
</ul>
<h3 id="处理概括关系"><a href="#处理概括关系" class="headerlink" title="处理概括关系"></a>处理概括关系</h3><h4 id="Pull-Up-Field-字段上移"><a href="#Pull-Up-Field-字段上移" class="headerlink" title="Pull Up Field (字段上移)"></a>Pull Up Field (字段上移)</h4><ul>
<li>两个子类拥有相同的字段</li>
<li>将该字段移至超类</li>
</ul>
<h4 id="Pull-Up-Method-函数上移"><a href="#Pull-Up-Method-函数上移" class="headerlink" title="Pull Up Method (函数上移)"></a>Pull Up Method (函数上移)</h4><ul>
<li>有些函数，在各个子类中产生完全相同的结果</li>
<li>将该函数移至超类</li>
</ul>
<h4 id="Pull-Up-Constructor-Body-构造函数本体上移"><a href="#Pull-Up-Constructor-Body-构造函数本体上移" class="headerlink" title="Pull Up Constructor Body (构造函数本体上移)"></a>Pull Up Constructor Body (构造函数本体上移)</h4><ul>
<li>你在各个子类中拥有一些构造函数，它们的本体几乎完全一致</li>
<li>在超类中新建一个构造函数，并在子类构造函数中调用它</li>
</ul>
<h4 id="Push-Down-Method-函数下移"><a href="#Push-Down-Method-函数下移" class="headerlink" title="Push Down Method (函数下移)"></a>Push Down Method (函数下移)</h4><ul>
<li>超类中的某个函数只与部分(而非全部)子类有关</li>
<li>将这个函数移到相关的那些子类去</li>
</ul>
<h4 id="Push-Down-Field-字段下移"><a href="#Push-Down-Field-字段下移" class="headerlink" title="Push Down Field (字段下移)"></a>Push Down Field (字段下移)</h4><ul>
<li>超类中的某个字段只被部分(而非全部)子类用到</li>
<li>将这个字段移到需要它的那些子类去</li>
</ul>
<h4 id="Extract-Superclass-提炼超类"><a href="#Extract-Superclass-提炼超类" class="headerlink" title="Extract Superclass (提炼超类)"></a>Extract Superclass (提炼超类)</h4><ul>
<li>两个类有相似特性</li>
<li>为这两个类建立一个超类，将相同特性移至超类</li>
</ul>
<h4 id="Extract-Interface-提炼接口"><a href="#Extract-Interface-提炼接口" class="headerlink" title="Extract Interface (提炼接口)"></a>Extract Interface (提炼接口)</h4><ul>
<li>若干客户使用类接口中的同一子类，或者两个类的接口有部分相同</li>
<li>将相同的子集提炼到一个独立接口中</li>
</ul>
<h4 id="Collapse-Hierarchy-折叠继承体系"><a href="#Collapse-Hierarchy-折叠继承体系" class="headerlink" title="Collapse Hierarchy (折叠继承体系)"></a>Collapse Hierarchy (折叠继承体系)</h4><ul>
<li>超类和子类之间无太大区别</li>
<li>将它们合为一体</li>
</ul>
<h4 id="Form-TemPlate-Method-塑造模版函数"><a href="#Form-TemPlate-Method-塑造模版函数" class="headerlink" title="Form TemPlate Method (塑造模版函数)"></a>Form TemPlate Method (塑造模版函数)</h4><ul>
<li>你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同</li>
<li>将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类</li>
</ul>
<h4 id="Replace-Inheritance-with-Delegation-以委托取代继承"><a href="#Replace-Inheritance-with-Delegation-以委托取代继承" class="headerlink" title="Replace Inheritance with Delegation (以委托取代继承)"></a>Replace Inheritance with Delegation (以委托取代继承)</h4><ul>
<li>某个子类只使用超类接口中的一部分，或是根本不需要继承而来的错误</li>
<li>在子类中新建一个字段用以保存超类;调查子类函数，令它改而委托超类;然后去掉两者之间的继承关系</li>
</ul>
<h4 id="Replace-Delegation-with-Inheritance-以继承取代委托"><a href="#Replace-Delegation-with-Inheritance-以继承取代委托" class="headerlink" title="Replace Delegation with Inheritance (以继承取代委托)"></a>Replace Delegation with Inheritance (以继承取代委托)</h4><ul>
<li>你在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数</li>
<li>让委托类继承受托类</li>
</ul>
<h3 id="大型重构"><a href="#大型重构" class="headerlink" title="大型重构"></a>大型重构</h3><p><del>理论上这一章配个图比较合适，不过我的书有水印不想截图，又懒得画类图，所以没有图</del></p>
<h4 id="Tease-Apart-Inheritance-梳理并分解继承体系"><a href="#Tease-Apart-Inheritance-梳理并分解继承体系" class="headerlink" title="Tease Apart Inheritance (梳理并分解继承体系)"></a>Tease Apart Inheritance (梳理并分解继承体系)</h4><ul>
<li>某个继承体系同时承担两项责任</li>
<li>建立两个继承体系，并通过委托让其中一个可以调用另一个</li>
</ul>
<h4 id="Convert-Procedural-Design-to-Objects-将过程化设计转化为对象设计"><a href="#Convert-Procedural-Design-to-Objects-将过程化设计转化为对象设计" class="headerlink" title="Convert Procedural Design to Objects (将过程化设计转化为对象设计)"></a>Convert Procedural Design to Objects (将过程化设计转化为对象设计)</h4><ul>
<li>你手上有一些传统过程化风格的代码</li>
<li>将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象之中</li>
</ul>
<h4 id="Separate-Domain-from-Presentation-将领域和表述-显示分离"><a href="#Separate-Domain-from-Presentation-将领域和表述-显示分离" class="headerlink" title="Separate Domain from Presentation (将领域和表述&#x2F;显示分离)"></a>Separate Domain from Presentation (将领域和表述&#x2F;显示分离)</h4><ul>
<li>某些GUI类之中包含了领域逻辑</li>
<li>将领域逻辑分离出来，为它们建立独立的领域类</li>
</ul>
<h4 id="Extract-Hierarchy-提炼继承体系"><a href="#Extract-Hierarchy-提炼继承体系" class="headerlink" title="Extract Hierarchy (提炼继承体系)"></a>Extract Hierarchy (提炼继承体系)</h4><ul>
<li>你有某个类做了太多工作，其中一部分工作是以大量条件表达式完成的</li>
<li>建立继承体系，以一个子类表述一种特殊情况</li>
</ul>
<h2 id="重构，复用与现实"><a href="#重构，复用与现实" class="headerlink" title="重构，复用与现实"></a>重构，复用与现实</h2><p>大约是一些重构在实际使用时的注意事项，比较碎而且涉及一些和甲方、上司的交涉之类的现实情况，目前对这一方面没什么理解，所以不整理了。<del>必然不是因为我懒</del></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JAVA/" rel="tag"># JAVA</a>
              <a href="/tags/%E9%87%8D%E6%9E%84/" rel="tag"># 重构</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/05/11/%E3%80%8A%E9%87%8D%E6%9E%84%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" rel="prev" title="《重构-改善既有代码的设计》学习笔记 (一)">
                  <i class="fa fa-angle-left"></i> 《重构-改善既有代码的设计》学习笔记 (一)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/07/02/%E3%80%8A%E6%B8%B8%E6%88%8F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B%E7%B2%BE%E7%B2%B9%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" rel="next" title="《游戏人工智能编程案例精粹》学习笔记（一）">
                  《游戏人工智能编程案例精粹》学习笔记（一） <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">tmc</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.umd.js" integrity="sha256-oyhjPiYRWGXaAt+ny/mTMWOnN1GBoZDUQnzzgC7FRI4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
